{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MLIR-based binary patching framework","text":"<p>Patchestry aims to make the same impact to binary patching as compilers and high level languages did to early software development. Its main goal is to enable developers without extensive knowledge of the deployment platform of the binary to patch the binary. To do this, the developer has to be confident that what they're patching is functionally equivalent to what is deployed and also that the patch they write will integrate into the deployed binary without issue.</p> <p>Patchestry leverages MLIR as the foundational technology instead of LLVM IR. MLIR is an emerging compiler development technology allowing for the specification, transformation, and mixing of IR dialects. The MLIR approach has significant industry momentum, and has been adopted by companies such as Google (in TensorFlow) and Meta (ClangIR). With MLIR, the decompilation process could be stratified into a Tower of IRs (IR dialects). Each IR represents the same program, but at a different level of abstraction.</p> <p>MLIR brings a notable advantage by enabling the creation of representations to streamline communication between diverse state-of-the-art tools. For instance, one can create an MLIR dialect specifically for P-Code (a program representation utilized by Ghidra) to optimize integration with the Ghidra decompiler. Alternatively, an LLVM IR dialect can be employed to compile back to the executable, and MLIR can support LLVM-based contract validation through a symbolic executor such as KLEE. Moreover, MLIR provides flexibility to devise our own dialects for representing contracts in specialized logic, such as SMT. Finally, our high-level dialect, developed under DARPA V-SPELLS, captures the intricacies of full-featured C. Our compiler stacks empower us to compile C into any of the previously mentioned representations, promoting seamless interconnection between them.</p>"},{"location":"#technical-rationale","title":"Technical Rationale","text":"<p>Our recent experience on AMP, as well as our performance on other DARPA binary analysis programs (PACE, CFAR, LOGAN, CGC, Cyber Fast Track), have led us to four guiding principles that we believe patching solutions for legacy software must follow in order to be successful.</p> <ol> <li> <p>Fully automated approaches are doomed to failure. In general, the process of decompilation is an inherently intractable problem. However, developers are often capable of distinguishing between decompilation outcomes deemed 'good' or 'bad', but encoding that kind of heuristic logic into a system invariably yields unpredictability and unsoundness.  Hence, we assert that the involvement of semi-skilled or skilled human developers is essential in the process. The best-case scenario is that a developer can use an existing source code patch as a guide. Given this patch, they can locate the corresponding vulnerable machine code within a binary using binary function symbol names. The worst-case scenario involves the ad hoc application of tools (e.g. BinDiff, BSim) and reverse engineering skills to an opaque binary blob that is without symbols or debugging information.</p> </li> <li> <p>Developers must be able to leverage pre-existing software development experience and not have to concern themselves with low level details. That is, they should be able to operate as if the original source code and build process/environments were available, and not be expected to have expert knowledge of every machine code language that may be encountered.</p> </li> <li> <p>From-scratch development efforts do not scale. As much as possible, pre-existing tooling that already handles the inherent scalability challenges in (de)compiling code for such a wide variety of platforms should be leveraged. For example the Ghidra decompiler can decompile over 100 machine code languages to C, and the Clang compiler can generate machine code for over 20 machine code languages. Rolling new solutions from scratch is impractical.</p> </li> <li> <p>There is no one-size-fits-all way of representing code. A \u201ccomplete\u201d solution to machine code decompilation only exists at the end of a long tail of special cases. Patchestry aims to provide decompilation to a familiar, C-like language. Patchestry will not, however, decompile to C or a specific ISO dialect thereof because some machine code constructs have no equivalents in C, while others are only loosely equivalent given non-conforming dialect extensions.</p> </li> </ol>"},{"location":"#project-goals","title":"Project Goals","text":"<p>Patchestry accomplishes its goals by integrating various innovative concepts guided by the four principles described in technical rationale:</p>"},{"location":"#unified-tooling-integration","title":"Unified Tooling Integration","text":"<p>Guided by the third principle\u2014recognizing the limitations of from-scratch development efforts\u2014Patchestry seamlessly integrates existing tooling for decompilation and recompilation in the binary patching process. Patchestry advocates a unified tooling integration approach using an MLIR Tower of Intermediate Representations (IRs) as a mediator between tools. This strategy enables the incorporation of cutting-edge (de)compiler tools into a cohesive system, allowing the utilization of specialized tools for each task and ensuring effectiveness and optimal outcomes across all desired functionalities.</p>"},{"location":"#incremental-decompilation","title":"Incremental Decompilation","text":"<p>Patchestry\u2019s innovative approach involves leveraging multiple program representations simultaneously across various layers of the Tower of IRs. While state-of-the-art decompilers already offer diverse representations, what sets the Tower of IRs apart is its capability to create custom user-defined abstractions (layers) while preserving relationships between these layers. This modular approach facilitates seamless incremental decompilation and recompilation processes. This is crucial for effortlessly devising specific abstractions tailored to unique platforms.</p>"},{"location":"#unifying-representations-for-contracts-patches-and-software","title":"Unifying Representations for Contracts, Patches, and Software","text":"<p>The Tower of IRs also aligns with the fourth guiding principle: There is no one-size-fits-all way of representing code.  Maintaining multiple representations simultaneously in the Tower of IRs allows us to establish meaningful relationships between them and innovate in how we connect tools and conduct analyses. Additionally, this approach allows us to consolidate all necessary components for patching within the same representation: patch description, contract description and the software. This unified strategy streamlines tooling for analysis and facilitates the recompilation of patched software, resulting in a single artifact that can undergo desired formal analyses, such as LLVM-based analysis.</p>"},{"location":"#declarative-patching-and-contracts-description","title":"Declarative Patching and Contracts Description","text":"<p>To address our second guiding principle, which emphasizes the importance of allowing developers to leverage their existing software development experience, we mandate that all interactions with patching occur in a language commonly understood by developers. Specifically, a C-like language. To facilitate this, we propose a declarative library designed for describing patches, their application. Following the same principle, Patchestry introduces contracts in C-like DSL. These contracts serve as constraints guiding both decompilation and recompilation, and they must hold at all relevant steps of each process.</p>"},{"location":"#decompilation-workflow","title":"Decompilation Workflow","text":"<p>Patchestry\u2019s technical approach is designed to enable the following seven-step workflow:</p> <ol> <li> <p>A developer is tasked with patching a vulnerability in a program binary running on a device. How the user acquires a copy of the binary (e.g. downloaded from a vendor\u2019s website, extracted from a network capture, extracted directly from a device over serial port or JTAG, etc.) is not part of the project.</p> </li> <li> <p>The developer loads the binary into the open-source Ghidra interactive decompiler. Developers will be enabled to leverage Ghidra\u2019s features and plugins to locate the function(s) to patch, though previous binary analysis expertise is not required. We anticipate that developers will apply tools such as BinDiff or BSim, rely on symbol names or debug information, or apply reverse engineering techniques.</p> </li> </ol> <p>The Patchestry workflow includes Ghidra because it is open-source and actively maintained by the National Security Agency and because it supports a wide variety of binary file formats (ELF, COFF, PE, etc.) and machine code languages used by medical devices. Ghidra also implements a battery of heuristics that act as good first guesses as to the locations and references between functions and data in the binary. Although perfect identification/recovery of functions, data, and data types in a binary is intractable, the value of interactivity in Ghidra is that the human developer can fix incorrect conclusions drawn by the decompiler\u2019s heuristics.</p> <p>There are two reasons why Patchestry\u2019s workflow does not allow the developer to modify Ghidra\u2019s decompilation output and then re-compile that into a patchable representation. First, Ghidra\u2019s decompilation is not guaranteed to be syntactically correct or compilable. This can be mitigated through developer effort; however, the level of effort increases with the complexity of and number of references in the target function(s). Second, Ghidra\u2019s heuristic decompilation pipeline has been proven to be unfaithful with respect to the execution semantics of the machine code. In the worst case, this could result in a developer inadvertently introducing new vulnerabilities into the program during the patching process.</p> <p>Despite Ghidra\u2019s decompilation not being precise enough for recompilation, our experience from AMP tells us that Ghidra\u2019s decompilation is good enough to be a productivity multiplier for developers trying to locate functions that need patching.</p> <p>Moreover, the modular design of Patchestry affords the flexibility to seamlessly integrate more formally rigorous decompilers and their representations in the future, as their capabilities align with our technical requirements. Currently, the majority of existing tools are predominantly of a research-oriented nature, often concentrating on x86 architecture or even just its subset, which is not sufficient for the diverse nature of software.</p> <ol> <li>After locating the relevant function(s) in Ghidra, the Patchestry plugin will present the developer with an editable decompilation of the target function(s). Patchestry\u2019s decompilations will be sound and precise with respect to the available information in Ghidra\u2019s analysis database. Regardless of how small the patch size could be, Patchestry will always formulate the problem at the function granularity. There are theoretical and pragmatic reasons why Patchestry\u2019s minimum patch recompilation granularity is function-at-a-time.</li> </ol> <p>From a theoretical standpoint, function granularity patches enable Patchestry to leverage stronger guarantees about the application binary interface (ABI). It is only at the entry and exit points of a compiled function that higher-level, human-readable types can be reliably mapped to low level machine locations (registers, memory).</p> <p>Patchestry leverages the open-source Clang compiler, which can already target relevant platforms. A restriction in compilers like Clang that nonetheless favors our approach is that functions are the smallest compilable unit of code. Our task in Patchestry is thus to convert code for recompilation into LLVM IR functions, which Clang can convert to machine code.</p> <ol> <li>The developer edits the decompiled function(s), enacting the necessary changes to patch the vulnerability in the decompiled code. Patchestry\u2019s highest level decompiled code (C-like) will look approximately similar, regardless of the platform/architecture of the medical device software. This will help improve developer productivity. Moreover, the meta-patch library will allow the developer to automate the patching process.</li> </ol> <p>At this stage, the binary-level patch has not yet been formulated. What particular changes are needed to patch a given vulnerability are beyond the scope of the project and require an external tool. Patchestry will, however, provide a library of \u201cpatch intrinsics\u201d such as \u201cadd bounds check.\u201d These will be formulated as templates of meta-patches.</p> <p>A developer can make near arbitrary changes within the body of the decompiled code (e.g. add, remove or replace its portions). Although Patchestry aims to provide verifiable guarantees about feature- and bug-compatibility of its decompilation with respect to the Ghidra database, absent contracts or specifications about the intended behavior of the code, Patchestry cannot make guarantees about the correctness of the edited decompilation. That is, Patchestry cannot prevent a developer from introducing new flaws into the binary, nor can it guarantee that a patch comprehensively fixes the root cause of the vulnerability.</p> <p>To mitigate the problem of developer- or decompiler-introduced emergent behaviors, Patchestry will allow developers to leverage model- and contract-based software verification techniques. These techniques are normally challenging to apply to lifting/decompilation due to a lack of end-to-end visibility into the lifting process; usually the techniques only apply at the very last stage, on the decompiled/lifted result. However, Patchestry\u2019s approach to decompilation is multi-level: decompilation progresses through a stage of increasingly high-level IRs. By taking a multi-level approach, Patchestry can instrument contracts at various stages of the process.</p> <ol> <li> <p>Verification of contracts. To ensure the reliability of patched code along with associated contracts, Patchestry offers a toolset for generating output compatible with both static and dynamic analysis tools. The optimal choice for this purpose is LLVM IR, given its verification confirms the fulfillment of contracts before its compilation. Patchestry allows for easy integration of LLVM-based analysis tools such as KLEE or SeaHorn, automating the verification process.</p> </li> <li> <p>Patchestry formulates the patch by compiling developer-edited decompiled function(s), and packages the patch for use by a binary patching tool. Patchestry will utilize a pre-existing tool, such as Patcherex or OFRAK, to enact the patch process, creating a new version of the binary.</p> </li> <li> <p>Finally, the developer will load the new version of the binary onto the device. How the developer loads the new version of the binary is not part of the project.</p> </li> </ol>"},{"location":"#architecture","title":"Architecture","text":"<p>The Patchestry design places a strong emphasis on modularity and seamless developer interaction. The developer plays a key role, providing the binary pieces to be patched, a patch description, and instructions on how to apply these patches using the meta-programming framework (meta-patches). Contracts are similarly specified and applied by instrumentation using the same meta-language. Utilizing state-of-the-art tools, we perform decompilation and program analysis.</p> <p>A significant architectural innovation is the MLIR Tower of IRs, which serves as the connecting element. This tower facilitates the association of representations between decompiled programs, such as from P-Code and compilable and structured representations like LLVM IR. The tower's modularity allows for the specification of any DSL for the decompiled program, with the only requirement being the translation of this DSL to a layer of the tower. In our case, Ghidra's P-Code serves as a suitable starting point layer. However, this modular design allows new decompilers to be integrated into Patchestry in the future while preserving the rest of the architecture.</p> <p>Utilizing the same representation (MLIR dialects) for both the decompiled binary and the compiled patched version facilitates seamless instrumentation and inlining of patches, ultimately producing a patched MLIR (Tower of IRs). The tower's various abstraction layers enable precise specification of points of interest, surpassing the limitations of a single representation. Additionally, the tower abstracts away from the decompiled representation (P-Code), facilitating modular design in the future.</p> <p>Contract handling follows a similar pattern. Described in a C-like language, contracts can take the form of static or runtime assertions or error handlers. These are inserted into the code while it is in the IR Tower form. Runtime checks are then compiled and remain in the patched binary. Static contracts are checked using a formal verifier. The flexibility to invent new contract mechanisms according to specific needs is a key feature.</p> <p>In the verification phase, which is the final step, Patchestry is designed to accommodate various verification methods. The Tower allows to produce a customized representation for the analysis, but it is advisable to stick to the same representation as the compilation (such as LLVM IR) to prevent errors during translation. Slicing the codebase into independent parts influenced by the patch makes LLVM-based static analysis of the representation with contracts tractable. We expect that most of the patches being local influence only a small part of the program, therefore using the dependency analysis, we can isolate the part of the program that needs to be verified.</p>"},{"location":"#cve-2021-22156-patching","title":"CVE-2021-22156 Patching","text":"<p>An example of patching the CVE-2021-22156 vulnerability, addressing an integer overflow within the <code>calloc()</code> function of the C standard library. This vulnerability affects versions of the BlackBerry QNX Software Development Platform (SDP) up to version 6.5.0SP1, QNX OS for Medical up to version 1.1, and QNX OS for Safety up to version 1.0.1. A malicious actor could exploit this integer overflow issue to execute arbitrary code or initiate a denial of service attack.</p> <p>Consider the vulnerable code snippet below. Here, a user-defined function, <code>get_num_elements()</code>, is employed to determine the size requirements for a dynamic array of long integers assigned to the variable num_elements. During the allocation of the buffer using <code>calloc()</code>, the variable num_elements is multiplied by sizeof(long) to calculate the overall size requirements. If the resulting multiplication exceeds the representable range of <code>size_t</code>, <code>calloc()</code> may allocate a zeroed buffer of insufficient size. Subsequently, when data is copied into this buffer, an overflow may occur, posing a potential security risk.</p> <p>A vulnerable code in which the standard library function <code>calloc()</code> may allocate a zeroed buffer of insufficient size:</p> <pre><code>size_t num_elements = get_num_elements(); // from the outside environment\n\nlong *buffer = (long *)calloc(num_elements, sizeof(long));\n\nif (buffer == NULL) {\n    /* Handle error condition */\n}\n</code></pre> <p>The desired result of applying Patchestry to fix the vulnerable code:</p> <pre><code>size_t num_elements = get_num_elements(); // from the outside environment\n\n/* Patch start */\nif (num_elements &gt; SIZE_MAX/sizeof(long)) {\n    /*  Handle error condition */\n}\n/* Patch end */\n\nlong *buffer = (long *)calloc(num_elements, sizeof(long));\nif (buffer == NULL) {\n    /* Handle error condition */\n    return;\n}\n</code></pre> <p>To create this simple patch, we require two essential components: the patch itself and the specific locations where the patch should be applied. In Patchestry, we offer developers a library, allowing them to articulate these components using familiar C-like syntax:</p> <pre><code>// 1. Patch in C\n[[CVE-2021-22156]] void patch(size_t num_elements) {\n    if (num_elements &gt; SIZE_MAX/sizeof(long)) {\n            /*  Handle error condition  */\n    }\n}\n\n// 2. Developer-defined meta-patch transformation\nvoid meta_patch(source_module_t module) {\n    for (const callsite_t &amp;place : module.calls(\"calloc\")) {\n        place.apply_before(\"CVE-2021-22156::patch\", { place.operand(1) });\n    }\n}\n</code></pre> <p>Patchestry introduces a metaprogramming interface enabling  developer-defined code transformations. Patchestry\u2019s interface supports common patching operations such as code insertion, replacement, alteration, and deletion. To obtain the source module from the program binary, we leverage state-of-the-art decompilers and seamlessly integrate them into the MLIR source representation, as elaborated later. Patchestry\u2019s source representation can be modified and queried through the metaprogramming API.</p> <p>The second crucial aspect of Patchestry involves providing assurances regarding patches. Similar to the patching process, we empower developers to define contracts in our C-like language, and seamlessly embed these checks into the binary. Unlike patches, contracts are mandated not to alter program state. There are two types of contracts in Patchestry: runtime contracts, addressing unexpected states during runtime, and static contracts, exclusively used for formal verification without persisting in the compiled binary.</p> <pre><code>// Contract\n[[CVE-2021-22156]] void contract(size_t num_elements) {\n    assert(num_elements &lt;= SIZE_MAX/sizeof(long));\n}\n// Meta-contract\nvoid meta_contract(source_module_t module) {\n    for (const callsite_t &amp;place : module.calls(\"calloc\")) {\n        place.apply_before(\"CVE-2021-22156::contract\", { place.operand(1) });\n    }\n}\n</code></pre> <p>An example of Patchestry contract that defines the expected functionality of the program under test written in the C-like Patchestry contracts DSL. A contract is similar to a regression test or a behavioral assertion that an analysis tool like KLEE would check.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Patchestry","text":"<p>First, thanks for your interest in contributing to Patchestry! We welcome and appreciate all contributions, including bug reports, feature suggestions, tutorials/blog posts, and code improvements.</p> <p>If you're unsure where to start, we recommend our <code>good first issue</code> issue label.</p>"},{"location":"CONTRIBUTING/#bug-reports-and-feature-suggestions","title":"Bug reports and feature suggestions","text":"<p>Bug reports and feature suggestions can be submitted to our issue tracker.</p> <p>When reporting a bug please provide a minimal example with steps to reproduce the issue if possible. It helps us a lot, as we can get to the bottom of the issue much faster and can even use it as a test case to catch future regressions.</p>"},{"location":"CONTRIBUTING/#questions","title":"Questions","text":"<p>Questions can be submitted to the discussion page.</p>"},{"location":"CONTRIBUTING/#legal","title":"Legal","text":"<p>For legal reasons, we require contributors to sign our Contributor License Agreement.  This will be automatically checked as part of our CI.</p>"},{"location":"CONTRIBUTING/#git-pull-requests","title":"Git &amp; Pull Requests","text":"<p>Patchestry uses the pull request contribution model. Please make an account on Github, fork this repo, and submit code contributions via pull request. For more documentation, look here.</p> <p>Since Patchestry does not squash commits in a pull request, it is important to uphold some culture when it comes to commits.</p> <ul> <li>Commit should ideally be one simple change.</li> <li>Commit messages follow a simple format:   <code>component: Simple sentence with a dot.</code> with maximum of 80 chars and optional longer   message.</li> <li>When unsure what component commit modifies, run <code>git log</code> on the modified file(s).</li> <li>Commits should modify only one component (as a result the project does not have   to build with each separate commit)</li> <li>If you are having troubles coming up with a simple sentence as a commit message,   that is short enough, it may be a good indicator that the commit should be split.</li> </ul> <p>Some pull request guidelines:</p> <ul> <li>Minimize irrelevant changes (formatting, whitespace, etc) to code that would   otherwise not be touched by this patch. Save formatting or style corrections   for a separate pull request that does not make any semantic changes.</li> <li>When possible, large changes should be split up into smaller focused pull   requests.</li> <li>Fill out the pull request description with a summary of what your patch does,   key changes that have been made, and any further points of discussion, if   applicable.</li> <li>Title your pull request with a brief description of what it's changing.   \"Fixes #123\" is a good comment to add to the description, but makes for an   unclear title on its own.</li> <li>CI must pass for the PR to be merged.</li> <li>There must be a review from some maintainer that accepts changes for the PR to be merged.</li> </ul>"},{"location":"statement/","title":"License","text":"<p>Patchestry is licensed according to the Apache 2.0 license. Patchestry links against and uses Clang and LLVM APIs. Clang is also licensed under Apache 2.0, with LLVM exceptions.</p> <p>This research was developed with funding from the Advanced Research Projects Agency for Health (ARPA-H). The views, opinions and/or findings expressed are those of the author and should not be interpreted as representing the official views or policies of the U.S. Government.</p>"},{"location":"Dialects/Contracts/","title":"Contracts","text":""},{"location":"Dialects/Contracts/#contracts-dialect","title":"'contracts' Dialect","text":"<p>Static contracts as attributes</p> <p>Declarative pre/post conditions attached to operations.</p> <ul> <li>'contracts' Dialect<ul> <li>Attributes<ul> <li>ContractAlignmentAttr<ul> <li>Parameters:</li> </ul> </li> <li>ContractAllOfAttr<ul> <li>Parameters:</li> </ul> </li> <li>ContractAnyOfAttr<ul> <li>Parameters:</li> </ul> </li> <li>PostconditionAttr<ul> <li>Parameters:</li> </ul> </li> <li>PreconditionAttr<ul> <li>Parameters:</li> </ul> </li> <li>PredicateAttr<ul> <li>Parameters:</li> </ul> </li> <li>ContractRangeAttr<ul> <li>Parameters:</li> </ul> </li> <li>StaticContractAttr<ul> <li>Parameters:</li> </ul> </li> <li>SymbolNameAttr<ul> <li>Parameters:</li> </ul> </li> <li>TargetAttr<ul> <li>Parameters:</li> </ul> </li> </ul> </li> <li>Enums<ul> <li>PredicateKind<ul> <li>Cases:</li> </ul> </li> <li>RelationKind<ul> <li>Cases:</li> </ul> </li> <li>TargetKind<ul> <li>Cases:</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"Dialects/Contracts/#attributes","title":"Attributes","text":""},{"location":"Dialects/Contracts/#contractalignmentattr","title":"ContractAlignmentAttr","text":"<p>Alignment requirement (bytes)</p> <p>Syntax:</p> <pre><code>#contracts.align&lt;\n  uint64_t   # alignment\n&gt;\n</code></pre>"},{"location":"Dialects/Contracts/#parameters","title":"Parameters:","text":"Parameter C++ type Description alignment <code>uint64_t</code>"},{"location":"Dialects/Contracts/#contractallofattr","title":"ContractAllOfAttr","text":"<p>Conjunction of clauses</p> <p>Syntax:</p> <pre><code>#contracts.all_of&lt;\n  ::llvm::ArrayRef&lt;mlir::Attribute&gt;   # clauses\n&gt;\n</code></pre>"},{"location":"Dialects/Contracts/#parameters_1","title":"Parameters:","text":"Parameter C++ type Description clauses <code>::llvm::ArrayRef&lt;mlir::Attribute&gt;</code>"},{"location":"Dialects/Contracts/#contractanyofattr","title":"ContractAnyOfAttr","text":"<p>Disjunction of clauses</p> <p>Syntax:</p> <pre><code>#contracts.any_of&lt;\n  ::llvm::ArrayRef&lt;mlir::Attribute&gt;   # clauses\n&gt;\n</code></pre>"},{"location":"Dialects/Contracts/#parameters_2","title":"Parameters:","text":"Parameter C++ type Description clauses <code>::llvm::ArrayRef&lt;mlir::Attribute&gt;</code>"},{"location":"Dialects/Contracts/#postconditionattr","title":"PostconditionAttr","text":"<p>Postcondition requirement</p> <p>Syntax:</p> <pre><code>#contracts.post&lt;\n  mlir::StringAttr,   # id\n  contracts::PredicateAttr   # pred\n&gt;\n</code></pre>"},{"location":"Dialects/Contracts/#parameters_3","title":"Parameters:","text":"Parameter C++ type Description id <code>mlir::StringAttr</code> pred <code>contracts::PredicateAttr</code>"},{"location":"Dialects/Contracts/#preconditionattr","title":"PreconditionAttr","text":"<p>Precondition requirement</p> <p>Syntax:</p> <pre><code>#contracts.pre&lt;\n  mlir::StringAttr,   # id\n  contracts::PredicateAttr   # pred\n&gt;\n</code></pre>"},{"location":"Dialects/Contracts/#parameters_4","title":"Parameters:","text":"Parameter C++ type Description id <code>mlir::StringAttr</code> pred <code>contracts::PredicateAttr</code>"},{"location":"Dialects/Contracts/#predicateattr","title":"PredicateAttr","text":"<p>Predicate for precondition/postcondition</p>"},{"location":"Dialects/Contracts/#parameters_5","title":"Parameters:","text":"Parameter C++ type Description kind <code>::contracts::PredicateKind</code> target <code>contracts::TargetAttr</code> relation <code>::contracts::RelationKind</code> value <code>mlir::Attribute</code> align <code>contracts::ContractAlignmentAttr</code> expr <code>mlir::StringAttr</code> range <code>contracts::ContractRangeAttr</code>"},{"location":"Dialects/Contracts/#contractrangeattr","title":"ContractRangeAttr","text":"<p>Value range constraint</p> <p>Syntax:</p> <pre><code>#contracts.range&lt;\n  mlir::IntegerAttr,   # min\n  mlir::IntegerAttr   # max\n&gt;\n</code></pre>"},{"location":"Dialects/Contracts/#parameters_6","title":"Parameters:","text":"Parameter C++ type Description min <code>mlir::IntegerAttr</code> max <code>mlir::IntegerAttr</code>"},{"location":"Dialects/Contracts/#staticcontractattr","title":"StaticContractAttr","text":"<p>Static contract container</p>"},{"location":"Dialects/Contracts/#parameters_7","title":"Parameters:","text":"Parameter C++ type Description preconditions <code>::llvm::ArrayRef&lt;mlir::Attribute&gt;</code> postconditions <code>::llvm::ArrayRef&lt;mlir::Attribute&gt;</code>"},{"location":"Dialects/Contracts/#symbolnameattr","title":"SymbolNameAttr","text":"<p>Symbolic variable name</p> <p>Syntax:</p> <pre><code>#contracts.symname&lt;\n  mlir::StringAttr   # name\n&gt;\n</code></pre>"},{"location":"Dialects/Contracts/#parameters_8","title":"Parameters:","text":"Parameter C++ type Description name <code>mlir::StringAttr</code>"},{"location":"Dialects/Contracts/#targetattr","title":"TargetAttr","text":"<p>Target selector (arg | return_value | symbol @name)"},{"location":"Dialects/Contracts/#parameters_9","title":"Parameters:","text":"Parameter C++ type Description kind <code>::contracts::TargetKind</code> index <code>uint64_t</code> symbol <code>mlir::FlatSymbolRefAttr</code>"},{"location":"Dialects/Contracts/#enums","title":"Enums","text":""},{"location":"Dialects/Contracts/#predicatekind","title":"PredicateKind","text":"<p>predicate kind</p>"},{"location":"Dialects/Contracts/#cases","title":"Cases:","text":"Symbol Value String nonnull <code>0</code> nonnull relation <code>1</code> relation alignment <code>2</code> alignment expr <code>3</code> expr range <code>4</code> range"},{"location":"Dialects/Contracts/#relationkind","title":"RelationKind","text":"<p>relation predicate</p>"},{"location":"Dialects/Contracts/#cases_1","title":"Cases:","text":"Symbol Value String none <code>0</code> none lt <code>1</code> lt lte <code>2</code> lte gt <code>3</code> gt gte <code>4</code> gte eq <code>5</code> eq neq <code>6</code> neq"},{"location":"Dialects/Contracts/#targetkind","title":"TargetKind","text":"<p>predicate target</p>"},{"location":"Dialects/Contracts/#cases_2","title":"Cases:","text":"Symbol Value String Arg <code>0</code> Arg ReturnValue <code>1</code> ReturnValue Symbol <code>2</code> Symbol"},{"location":"Dialects/Pcode/","title":"Pcode","text":""},{"location":"Dialects/Pcode/#pc-dialect","title":"'pc' Dialect","text":"<p>Dialect for representing ghidra pcode operations.</p> <ul> <li>'pc' Dialect<ul> <li>Operations<ul> <li>pc.block (::patchestry::pc::BlockOp)<ul> <li>Attributes:</li> </ul> </li> <li>pc.bool_negate (::patchestry::pc::BoolNegateOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>pc.branch (::patchestry::pc::BranchOp)<ul> <li>Operands:</li> </ul> </li> <li>pc.call (::patchestry::pc::CallOp)<ul> <li>Operands:</li> </ul> </li> <li>pc.cbranch (::patchestry::pc::CBranchOp)<ul> <li>Operands:</li> </ul> </li> <li>pc.const (::patchestry::pc::ConstOp)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> <li>pc.copy (::patchestry::pc::CopyOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>pc.func (::patchestry::pc::FuncOp)<ul> <li>Attributes:</li> </ul> </li> <li>pc.instruction (::patchestry::pc::InstOp)<ul> <li>Attributes:</li> </ul> </li> <li>pc.int_add (::patchestry::pc::IntAddOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>pc.int_and (::patchestry::pc::IntAndOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>pc.int_equal (::patchestry::pc::IntEqualOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>pc.int_less (::patchestry::pc::IntLessOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>pc.int_sborrow (::patchestry::pc::IntSBorrowOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>pc.int_sless (::patchestry::pc::IntSLessOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>pc.int_sub (::patchestry::pc::IntSubOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>pc.load (::patchestry::pc::LoadOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>pc.mem (::patchestry::pc::MemOp)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> <li>pc.popcount (::patchestry::pc::PopcountOp)<ul> <li>Operands:</li> <li>Results:</li> </ul> </li> <li>pc.reg (::patchestry::pc::RegOp)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> <li>pc.return (::patchestry::pc::ReturnOp)<ul> <li>Operands:</li> </ul> </li> <li>pc.store (::patchestry::pc::StoreOp)<ul> <li>Operands:</li> </ul> </li> <li>pc.var (::patchestry::pc::VarOp)<ul> <li>Attributes:</li> <li>Results:</li> </ul> </li> </ul> </li> <li>Types<ul> <li>ConstType</li> <li>MemType</li> <li>RegType</li> <li>VarType</li> </ul> </li> </ul> </li> </ul>"},{"location":"Dialects/Pcode/#operations","title":"Operations","text":""},{"location":"Dialects/Pcode/#pcblock-patchestrypcblockop","title":"<code>pc.block</code> (::patchestry::pc::BlockOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.block` $sym_name attr-dict `:` $instructions\n</code></pre> <p>Traits: <code>NoTerminator</code></p>"},{"location":"Dialects/Pcode/#attributes","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>sym_name</code>::mlir::StringAttrstring attribute"},{"location":"Dialects/Pcode/#pcbool_negate-patchestrypcboolnegateop","title":"<code>pc.bool_negate</code> (::patchestry::pc::BoolNegateOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.bool_negate` $op attr-dict `:` functional-type(operands, results)\n</code></pre> <p>Traits: <code>SameOperandsAndResultType</code></p> <p>Interfaces: <code>InferTypeOpInterface</code></p>"},{"location":"Dialects/Pcode/#operands","title":"Operands:","text":"Operand Description <code>op</code> signless integer"},{"location":"Dialects/Pcode/#results","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcbranch-patchestrypcbranchop","title":"<code>pc.branch</code> (::patchestry::pc::BranchOp)","text":"<p>Pcode BRANCH operation</p> <p>Syntax:</p> <pre><code>operation ::= `pc.branch` $addr attr-dict `:` type(operands)\n</code></pre> <p>TBD</p>"},{"location":"Dialects/Pcode/#operands_1","title":"Operands:","text":"Operand Description <code>addr</code> signless integer"},{"location":"Dialects/Pcode/#pccall-patchestrypccallop","title":"<code>pc.call</code> (::patchestry::pc::CallOp)","text":"<p>Pcode CALL operation</p> <p>Syntax:</p> <pre><code>operation ::= `pc.call` $addr attr-dict `:` type(operands)\n</code></pre> <p>TBD</p>"},{"location":"Dialects/Pcode/#operands_2","title":"Operands:","text":"Operand Description <code>addr</code> signless integer"},{"location":"Dialects/Pcode/#pccbranch-patchestrypccbranchop","title":"<code>pc.cbranch</code> (::patchestry::pc::CBranchOp)","text":"<p>Pcode CBRANCH operation</p> <p>Syntax:</p> <pre><code>operation ::= `pc.cbranch` $addr `,` $cond attr-dict `:` type(operands)\n</code></pre> <p>TBD</p>"},{"location":"Dialects/Pcode/#operands_3","title":"Operands:","text":"Operand Description <code>addr</code> signless integer <code>cond</code> signless integer"},{"location":"Dialects/Pcode/#pcconst-patchestrypcconstop","title":"<code>pc.const</code> (::patchestry::pc::ConstOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.const` attr-dict `:` type($result)\n</code></pre> <p>Traits: <code>ConstantLike</code></p> <p>Interfaces: <code>InferTypeOpInterface</code></p>"},{"location":"Dialects/Pcode/#attributes_1","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>value</code>::mlir::TypedAttrTypedAttr instance{{% markdown %}}     This interface is used for attributes that have a type. The type of an     attribute is understood to represent the type of the data contained in the     attribute and is often used as the type of a value with this data.   {{% /markdown %}}"},{"location":"Dialects/Pcode/#results_1","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"Dialects/Pcode/#pccopy-patchestrypccopyop","title":"<code>pc.copy</code> (::patchestry::pc::CopyOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.copy` $op attr-dict `:` functional-type(operands, results)\n</code></pre> <p>Traits: <code>SameOperandsAndResultType</code></p> <p>Interfaces: <code>InferTypeOpInterface</code></p>"},{"location":"Dialects/Pcode/#operands_4","title":"Operands:","text":"Operand Description <code>op</code> signless integer"},{"location":"Dialects/Pcode/#results_2","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcfunc-patchestrypcfuncop","title":"<code>pc.func</code> (::patchestry::pc::FuncOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.func` $sym_name attr-dict `:` $blocks\n</code></pre> <p>Traits: <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SymbolTable</code></p> <p>Interfaces: <code>Symbol</code></p>"},{"location":"Dialects/Pcode/#attributes_2","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>sym_name</code>::mlir::StringAttrstring attribute"},{"location":"Dialects/Pcode/#pcinstruction-patchestrypcinstop","title":"<code>pc.instruction</code> (::patchestry::pc::InstOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.instruction` attr-dict `:` $semantics\n</code></pre>"},{"location":"Dialects/Pcode/#attributes_3","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>inst_mnemonic</code>::mlir::StringAttrstring attribute"},{"location":"Dialects/Pcode/#pcint_add-patchestrypcintaddop","title":"<code>pc.int_add</code> (::patchestry::pc::IntAddOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_add` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_5","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_3","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcint_and-patchestrypcintandop","title":"<code>pc.int_and</code> (::patchestry::pc::IntAndOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_and` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_6","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_4","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcint_equal-patchestrypcintequalop","title":"<code>pc.int_equal</code> (::patchestry::pc::IntEqualOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_equal` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_7","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_5","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcint_less-patchestrypcintlessop","title":"<code>pc.int_less</code> (::patchestry::pc::IntLessOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_less` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_8","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_6","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcint_sborrow-patchestrypcintsborrowop","title":"<code>pc.int_sborrow</code> (::patchestry::pc::IntSBorrowOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_sborrow` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_9","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_7","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcint_sless-patchestrypcintslessop","title":"<code>pc.int_sless</code> (::patchestry::pc::IntSLessOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_sless` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_10","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_8","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcint_sub-patchestrypcintsubop","title":"<code>pc.int_sub</code> (::patchestry::pc::IntSubOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_sub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_11","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_9","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcload-patchestrypcloadop","title":"<code>pc.load</code> (::patchestry::pc::LoadOp)","text":"<p>Pcode LOAD operation</p> <p>Syntax:</p> <pre><code>operation ::= `pc.load` $addr_space `,` $addr attr-dict `:` functional-type(operands, results)\n</code></pre> <p>TBD</p>"},{"location":"Dialects/Pcode/#operands_12","title":"Operands:","text":"Operand Description <code>addr_space</code> signless integer <code>addr</code> signless integer"},{"location":"Dialects/Pcode/#results_10","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcmem-patchestrypcmemop","title":"<code>pc.mem</code> (::patchestry::pc::MemOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.mem` attr-dict `:` type($result)\n</code></pre>"},{"location":"Dialects/Pcode/#attributes_4","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>addr_space</code>::mlir::StringAttrstring attribute <code>addr</code>::mlir::IntegerAttr64-bit signless integer attribute <code>size</code>::mlir::IntegerAttr8-bit signless integer attribute"},{"location":"Dialects/Pcode/#results_11","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"Dialects/Pcode/#pcpopcount-patchestrypcpopcountop","title":"<code>pc.popcount</code> (::patchestry::pc::PopcountOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.popcount` $op attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_13","title":"Operands:","text":"Operand Description <code>op</code> signless integer"},{"location":"Dialects/Pcode/#results_12","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcreg-patchestrypcregop","title":"<code>pc.reg</code> (::patchestry::pc::RegOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.reg` attr-dict `:` type($result)\n</code></pre>"},{"location":"Dialects/Pcode/#attributes_5","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>addr_space</code>::mlir::StringAttrstring attribute <code>addr</code>::mlir::IntegerAttr64-bit signless integer attribute <code>size</code>::mlir::IntegerAttr8-bit signless integer attribute"},{"location":"Dialects/Pcode/#results_13","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"Dialects/Pcode/#pcreturn-patchestrypcreturnop","title":"<code>pc.return</code> (::patchestry::pc::ReturnOp)","text":"<p>Pcode RETURN operation</p> <p>Syntax:</p> <pre><code>operation ::= `pc.return` $varnode attr-dict `:` type(operands)\n</code></pre> <p>TBD</p>"},{"location":"Dialects/Pcode/#operands_14","title":"Operands:","text":"Operand Description <code>varnode</code> signless integer"},{"location":"Dialects/Pcode/#pcstore-patchestrypcstoreop","title":"<code>pc.store</code> (::patchestry::pc::StoreOp)","text":"<p>Pcode STORE operation</p> <p>Syntax:</p> <pre><code>operation ::= `pc.store` $addr_space `,` $addr `,` $data attr-dict `:` type(operands)\n</code></pre> <p>TBD</p>"},{"location":"Dialects/Pcode/#operands_15","title":"Operands:","text":"Operand Description <code>addr_space</code> signless integer <code>addr</code> signless integer <code>data</code> signless integer"},{"location":"Dialects/Pcode/#pcvar-patchestrypcvarop","title":"<code>pc.var</code> (::patchestry::pc::VarOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.var` attr-dict `:` type($result)\n</code></pre>"},{"location":"Dialects/Pcode/#attributes_6","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>addr_space</code>::mlir::StringAttrstring attribute <code>addr</code>::mlir::IntegerAttr64-bit signless integer attribute <code>size</code>::mlir::IntegerAttr8-bit signless integer attribute"},{"location":"Dialects/Pcode/#results_14","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"Dialects/Pcode/#types","title":"Types","text":""},{"location":"Dialects/Pcode/#consttype","title":"ConstType","text":"<p>Syntax: <code>!pc.const</code></p>"},{"location":"Dialects/Pcode/#memtype","title":"MemType","text":"<p>Syntax: <code>!pc.mem</code></p>"},{"location":"Dialects/Pcode/#regtype","title":"RegType","text":"<p>Syntax: <code>!pc.reg</code></p>"},{"location":"Dialects/Pcode/#vartype","title":"VarType","text":"<p>Syntax: <code>!pc.var</code></p>"},{"location":"GettingStarted/build/","title":"Building","text":"<p>We mostly rely on a build container, but some dependencies are still needed outside that container: our fork of LLVM20, a local copy of <code>lld</code>, and LLVM LIT.</p> <p>In order to set up those and build Patchestry, please follow the first-time instructions for your development environment of choice: - macOS - Linux</p> <p>See also: Development</p>"},{"location":"GettingStarted/build/#first-time-development-setup-macos","title":"First Time Development Setup: MacOS","text":"<ol> <li> <p>Install Xcode from the App Store and set up the command line tools:    <pre><code>xcode-select --install\n</code></pre></p> </li> <li> <p>Install the required dependencies using Homebrew:    <pre><code># basics\nbrew install colima docker docker-buildx docker-credential-helper cmake lit\n# to run tests, we need to cross-compile for x86-64/Linux and aarch64/Linux\nbrew install FiloSottile/musl-cross/musl-cross\n</code></pre></p> </li> <li> <p>Configure Docker BuildX to work with Colima:    <pre><code>mkdir -p ~/.docker/cli-plugins\nln -s $(which docker-buildx) ~/.docker/cli-plugins/docker-buildx\ncolima restart\ndocker buildx version\n</code></pre></p> </li> <li> <p>Log into Docker Hub (this may not be needed - it is not needed on Linux):    <pre><code>docker login -u &lt;username&gt;\n</code></pre></p> </li> <li> <p>For building ClangIR, clone the project and compile with the following CMake configuration:    <pre><code>cmake -G Ninja ../../llvm \\\n    -DCMAKE_INSTALL_PREFIX=\"/path/to/installdir\" \\\n    -DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n    -DLLVM_ENABLE_PROJECTS=\"clang;mlir;clang-tools-extra\" \\\n    -DLLVM_ENABLE_ASSERTIONS=ON \\\n    -DCLANG_ENABLE_CIR=ON \\\n    -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \\\n    -DLLVM_ENABLE_RTTI=ON \\\n    -DLLVM_INSTALL_UTILS=ON \\\n    -DLLVM_TARGETS_TO_BUILD=\"host;AArch64;ARM;X86\"\n</code></pre></p> </li> </ol> <p>The targets list of <code>\"host;AArch64;ARM;X86\"</code> is intentional (to always build host arch, AArch64, ARM, and x86), even if host arch is almost certainly either AArch64 or X86.</p> <ol> <li>Build with: <pre><code>CC=$(which clang) CXX=$(which clang++) cmake \\\n   --preset default \\\n   -DCMAKE_PREFIX_PATH=&lt;path_to_llvm_install&gt;/lib/cmake/ \\\n   -DLLVM_EXTERNAL_LIT=$(which lit)\n</code></pre></li> </ol> <p>This setup provides a complete development environment for building and running the project on MacOS. The configuration uses Colima as a Docker backend, which provides better performance and resource management compared to Docker Desktop on MacOS.</p>"},{"location":"GettingStarted/build/#first-time-development-setup-linux","title":"First Time Development Setup: Linux","text":"<p>If you'd like to either follow step by step instructions or run a script to automatically follow them in a fresh Linux instance, here's a Gist that sets everything up from zero in a fresh VM for you and runs the Patchestry tests to confirm the setup works. This Gist should stay reasonably up to date since it's used to initialize ephemeral coding environments. It's been tested on Ubuntu 24.04. The only thing that should be different for other Ubuntus or for Debian is the <code>apt</code> package naming.</p> <p>Steps followed in the Gist to get to a working install: 1. Base dependency install (Docker, lld, build tools such as CMake) 2. Acquire LLVM LIT from Python Pip 3. Build and install LLVM 4. Build and install Patchestry 5. Build the headless container in the Patchestry repository (this should set up and install Ghidra and everything else) 6. Run tests for Patchestry, which requires the container / occurs in the container</p>"},{"location":"GettingStarted/build/#development","title":"Development","text":""},{"location":"GettingStarted/build/#cmake-commands","title":"CMake Commands","text":"<ul> <li>to build, see the command referenced in step 6 above or the commands used for Linux. You'll use the <code>default</code> preset to configure and most likely the <code>debug</code> or <code>release</code> presets for the subsequent build command after configuration.</li> <li>to run tests, ensure the headless container is available first by running <code>scripts/ghidra/build-headless-docker.sh</code>, then you may <code>cmake --build builds/default/ -j$((</code>nproc<code>+1)) --preset debug --target test</code> (using the preset of your choice but selecting the <code>test</code> target)</li> </ul>"},{"location":"GettingStarted/build/#ghidra","title":"Ghidra","text":""},{"location":"GettingStarted/build/#installing-ghidra-locally","title":"Installing Ghidra Locally","text":"<p>You shouldn't need to do this directly in the current build most of the time. Prefer working in the headless container.  You may want Ghidra locally for Ghidra script debugging.</p> <p>Get Java JDK (x64) <pre><code>wget -c https://download.oracle.com/java/22/latest/jdk-22_linux-x64_bin.tar.gz -O jdk.tar.gz\ntar xvf jdk.tar.gz\nmv jdk-22.0.1 ~/jdk\necho \"export PATH=\\$PATH:~/jdk/bin\" &gt;&gt; ~/.bashrc\n</code></pre></p> <p>Get Ghidra <pre><code>wget -c https://github.com/NationalSecurityAgency/ghidra/releases/download/Ghidra_11.1.1_build/ghidra_11.1.1_PUBLIC_20240614.zip -O ghidra.zip\nunzip ghidra.zip\nmv ghidra_11.1.1_PUBLIC ~/ghidra\n</code></pre></p>"},{"location":"GettingStarted/firmware_examples/","title":"How To Run Patchestry on Firmware Examples","text":""},{"location":"GettingStarted/firmware_examples/#build-the-ghidra-docker-image","title":"Build the Ghidra docker image","text":"<p>First, make sure that the firwmare decompilation Ghidra docker image is set up correctly: <pre><code>$ sh scripts/ghidra/build-headless-docker.sh\n</code></pre></p> <p>This should succeed in building <code>docker.io/trailofbits/patchestry-decompilation:latest</code></p>"},{"location":"GettingStarted/firmware_examples/#build-the-firmware","title":"Build the Firmware","text":"<p>Use the firmware build script (which builds a Linux docker image) to build the firmware: <pre><code>sh firmwares/build.sh\n</code></pre></p> <p>This should produce the following outputs: <pre><code>ls -1 firmwares/output \nbloodlight-firmware.elf\npulseox-firmware.elf\n</code></pre></p>"},{"location":"GettingStarted/firmware_examples/#decompile-firmware-to-json-blob","title":"Decompile firmware to JSON blob","text":"<p>For each firmware blob you want to decompile, use the decompile-headless script to decompile it:</p> <pre><code>scripts/ghidra/decompile-headless.sh --input firmwares/output/bloodlight-firmware.elf --output ~/temp/patchestry/bloodlight-firmware.json \n</code></pre> <p>This should produce the output json file, which can be used with tools like <code>pcode-lifter</code>.</p>"},{"location":"GettingStarted/firmware_examples/#convert-it-to-json-to-cir","title":"Convert it to JSON to CIR","text":"<p>The JSON (which encompasses Ghidra high-pcode) can then be converted to ClangIR via <code>pcode-lifter</code> as follows: <pre><code>builds/default/tools/pcode-lifter/Release/pcode-lifter --input ~/temp/patchestry/pulseox-firmware.json --emit-cir --output ~/temp/patchestry/pulseox-firmware_cir --print-tu\n</code></pre></p> <p>The <code>--print-tu</code> argument is optional, it will emit C along with the ClangIR. The output looks like: <pre><code>ls -1 ~/temp/patchestry/pulseox-firmware_cir*\n/Users/artem/temp/patchestry/pulseox-firmware_cir.c\n/Users/artem/temp/patchestry/pulseox-firmware_cir.cir\n</code></pre></p>"},{"location":"GettingStarted/ghidra/","title":"Decompilation Framework","text":"<p>The directory contains a script that runs Ghidra in headless mode to decompile binary files, identifying and listing all functions while extracting their corresponding pcode.</p> <p>We support two decompilation modes:</p> <ol> <li>GUI-based: A user-friendly interface where functions can be decompiled interactively.</li> <li>Headless: Decompilation through a Docker script for automated, non-interactive use.</li> </ol>"},{"location":"GettingStarted/ghidra/#prerequisites","title":"Prerequisites","text":"<p>Before running the scripts, make sure you have the following installed:</p> <ul> <li>Docker: The scripts use a Docker container to run Ghidra in headless mode.</li> </ul> <p>To perform headless decompilation, you need to build a Docker container (<code>decompile-headless.dockerfile</code>) configured to run Ghidra in headless mode. You can do this by running the <code>build-headless-docker.sh</code> script.</p>"},{"location":"GettingStarted/ghidra/#running-headless-decompilation-script","title":"Running Headless Decompilation Script","text":"<p>The <code>decompile-headless.sh</code> script decompiles a binary file using Ghidra in headless mode, extracting pcode for either a specific function or all functions by default, and saving the output as json to a specified file <code>&lt;output-file&gt;</code>.</p> <p>To extract P-code for a particular function, use the <code>--function</code> flag; otherwise, it decompiles all functions if no function name is specified.</p> <p><code>sh ./decompile-headless.sh --input &lt;binary&gt; --function &lt;function-name&gt; --output &lt;output-file&gt;</code></p> <p>The script also list all functions in the binary using the <code>--list-functions</code> flag.</p> <p><code>sh ./decompile-headless.sh --input &lt;binary&gt; --list-functions --output &lt;output-file&gt;</code></p>"},{"location":"GettingStarted/ghidra/#running-patchestry-via-ghidra-gui","title":"Running Patchestry via Ghidra GUI","text":"<ol> <li> <p>Ensure Patchestry is available via PATH:     <pre><code>patchestry\n</code></pre></p> </li> <li> <p>Start Ghidra GUI:     <pre><code>~/ghidra/ghidraRun\n</code></pre></p> </li> <li> <p>Create a project and import a binary file.</p> </li> <li> <p>Run <code>PatchestryDecompileFunctions.java</code> in <code>single</code> or <code>all</code> mode to decompile single or all functions from a binary file.</p> </li> <li> <p>Run <code>PatchestryListFunctions.java</code> script to list all the functions in a binary file.</p> </li> </ol> <p>Note: Ghidra scripts must be installed. See the build section for details.</p>"},{"location":"GettingStarted/intrinsic_library/","title":"Patchestry Intrinsics Library","text":""},{"location":"GettingStarted/intrinsic_library/#overview","title":"Overview","text":"<p>The Patchestry Intrinsics Library provides a stable, comprehensive runtime API for developers to query the state of the patched program and access the YAML/MLIR metadata that drives patch insertion. It is specifically designed for ClangIR-based patching workflows, enabling runtime analysis and safe modification of target binaries.</p> <p>The library bridges the gap between patch specifications and runtime execution by providing functionality including runtime introspection for caller analysis and execution context, memory safety through validation/corruption detection, program state access for structures, fields, and registers, and patch orchestration with mutability controls and error handling.</p> <p>These intrinsics enable developers to write robust, debuggable patches with comprehensive visibility into program behavior and patch execution context.</p>"},{"location":"GettingStarted/intrinsic_library/#architecture","title":"Architecture","text":""},{"location":"GettingStarted/intrinsic_library/#core-components","title":"Core Components","text":"<ol> <li>Runtime Introspection - Functions for runtime analysis and metadata access</li> <li>Safety Checks - Nullability, bounds checking, and assertion utilities  </li> <li>Device Management - Structured field access and device state</li> <li>Patch Utilities - Common patch application helpers</li> </ol>"},{"location":"GettingStarted/intrinsic_library/#header-structure","title":"Header Structure","text":"<pre><code>include/patchestry/intrinsics/\n\u251c\u2500\u2500 patchestry_intrinsics.h     # Main header for patch inclusion\n\u251c\u2500\u2500 runtime.h                   # Runtime introspection functions\n\u251c\u2500\u2500 safety.h                    # Safety and validation checks\n\u251c\u2500\u2500 device.h                    # Device structure access utilities\n\u2514\u2500\u2500 patch_utils.h              # Patch application utilities\n</code></pre>"},{"location":"GettingStarted/intrinsic_library/#intrinsic-api-reference","title":"Intrinsic API Reference","text":"<p>The intrinsic libraries will support the list of functions that can be embedded directly to the target binary during patching:</p>"},{"location":"GettingStarted/intrinsic_library/#1-runtime-introspection-apis","title":"1. Runtime Introspection APIs","text":"<pre><code>// Caller Information\nconst char* __patchestry_get_caller_name(void);\nconst char* __patchestry_get_caller_at_depth(int depth);\n\n// Thread and CPU Information\nuint32_t __patchestry_get_thread_id(void);\nuint32_t __patchestry_get_cpu_id(void);\nuint32_t __patchestry_get_process_id(void);\n\nconst char* __patchestry_get_return_type(const char* func_name);\n</code></pre>"},{"location":"GettingStarted/intrinsic_library/#2-memory-safety-apis","title":"2. Memory Safety APIs","text":"<pre><code>// Pointer Validation\nbool __patchestry_is_null_pointer(void* ptr);\nbool __patchestry_is_valid_pointer(void* ptr);\nbool __patchestry_is_readable(void* ptr, size_t size);\nbool __patchestry_is_writable(void* ptr, size_t size);\n\n// Bounds Checking\nbool __patchestry_check_bounds(void* ptr, size_t offset, size_t size);\nbool __patchestry_check_buffer_write(void* buffer, size_t buffer_size, size_t write_size);\nbool __patchestry_check_string_bounds(const char* str, size_t max_len);\n\n// Memory State\nbool __patchestry_is_initialized(void* ptr, size_t size);\n</code></pre>"},{"location":"GettingStarted/intrinsic_library/#3-assertion-and-validation-apis","title":"3. Assertion and Validation APIs","text":"<pre><code>// Assertion Macros\n#define PATCHESTRY_ASSERT(cond, msg)\n#define PATCHESTRY_ASSERT_NOT_NULL(ptr, msg)\n#define PATCHESTRY_ASSERT_BOUNDS(ptr, size, msg)\n\n// Conditional Guards\n#define PATCHESTRY_IF_VALID(ptr, block)\n#define PATCHESTRY_RETURN_IF_NULL(ptr, retval)\n#define PATCHESTRY_RETURN_IF_INVALID(cond, retval)\n</code></pre>"},{"location":"GettingStarted/intrinsic_library/#4-structure-and-field-access-apis","title":"4. Structure and Field Access APIs","text":"<pre><code>// Generic Field Access\n#define PATCHESTRY_GET_FIELD(struct_ptr, field_name, field_type)\n#define PATCHESTRY_SET_FIELD(struct_ptr, field_name, value, field_type)\n\n// Array Operations\n#define PATCHESTRY_ARRAY_GET(array, index, size, type)\nbool __patchestry_check_array_bounds(void* array, size_t array_size, size_t index, size_t elem_size);\n</code></pre>"},{"location":"GettingStarted/intrinsic_library/#5-device-and-hardware-apis","title":"5. Device and Hardware APIs","text":"<pre><code>// Device State Management\ntypedef enum {\n    PATCHESTRY_DEVICE_VALID,\n    PATCHESTRY_DEVICE_NULL,\n    PATCHESTRY_DEVICE_BUSY,\n    PATCHESTRY_DEVICE_ERROR\n} patchestry_device_state_t;\n\npatchestry_device_state_t __patchestry_device_state(void* device);\n\n// Register Access\nuint32_t __patchestry_read_reg32(volatile uint32_t* reg);\nvoid __patchestry_write_reg32(volatile uint32_t* reg, uint32_t value);\nbool __patchestry_is_valid_register(void* reg_addr);\n</code></pre>"},{"location":"GettingStarted/intrinsic_library/#6-mutability-and-access-control-apis","title":"6. Mutability and Access Control APIs","text":"<pre><code>// Mutability Control\nbool __patchestry_is_mutable(void* ptr, size_t size);\n\n// Access Permissions\ntypedef enum {\n    PATCHESTRY_ACCESS_READ    = 1,\n    PATCHESTRY_ACCESS_WRITE   = 2,\n    PATCHESTRY_ACCESS_EXECUTE = 4\n} patchestry_access_t;\n\nbool __patchestry_check_access(void* ptr, patchestry_access_t access);\n</code></pre>"},{"location":"GettingStarted/intrinsic_library/#7-logging-and-debugging-apis","title":"7. Logging and Debugging APIs","text":"<pre><code>// Logging Levels\ntypedef enum {\n    PATCHESTRY_LOG_DEBUG,\n    PATCHESTRY_LOG_INFO,\n    PATCHESTRY_LOG_WARN,\n    PATCHESTRY_LOG_ERROR,\n    PATCHESTRY_LOG_FATAL\n} patchestry_log_level_t;\n\n// Logging Macros\n#define PATCHESTRY_DEBUG(fmt, ...)\n#define PATCHESTRY_INFO(fmt, ...)\n#define PATCHESTRY_ERROR(fmt, ...)\n\n// Debug Utilities\nvoid __patchestry_dump_memory(void* ptr, size_t size, const char* label);\nvoid __patchestry_dump_struct(void* struct_ptr, const char* struct_type);\n</code></pre>"},{"location":"GettingStarted/intrinsic_library/#8-patch-context-and-metadata-apis","title":"8. Patch Context and Metadata APIs","text":"<pre><code>// Context Management\ntypedef struct {\n    const char* patch_name;\n    const char* target_function;\n    void* user_data;\n} patchestry_context_t;\n\npatchestry_context_t* __patchestry_get_context(void);\nconst char* __patchestry_get_patch_name(void);\nconst char* __patchestry_get_patch_version(void);\n\n// ClangIR Metadata Generation (Not implemented yet)\nvoid __patchestry_emit_metadata(const char* key, const char* value);\nvoid __patchestry_emit_annotation(const char* annotation);\n\n// Execution Tracking\nvoid __patchestry_mark_patch_start(const char* patch_name);\nvoid __patchestry_mark_patch_end(const char* patch_name);\nbool __patchestry_is_patch_active(const char* patch_name);\n</code></pre>"},{"location":"GettingStarted/intrinsic_library/#9-security-apis","title":"9. Security APIs","text":"<pre><code>// Random Number Generation\nuint32_t __patchestry_random_u32(void);\nvoid __patchestry_random_bytes(void* buffer, size_t size);\n</code></pre>"},{"location":"GettingStarted/intrinsic_library/#10-performance-and-profiling-apis","title":"10. Performance and Profiling APIs","text":"<pre><code>// Timing\ntypedef uint64_t patchestry_time_t;\npatchestry_time_t __patchestry_get_time(void);\ndouble __patchestry_time_diff_ms(patchestry_time_t start, patchestry_time_t end);\n\n// Profiling\nvoid __patchestry_profile_start(const char* name);\nvoid __patchestry_profile_end(const char* name);\nvoid __patchestry_profile_report(void);\n</code></pre>"},{"location":"GettingStarted/intrinsic_library/#basic-patch-template","title":"Basic Patch Template","text":"<pre><code>#include &lt;patchestry/intrinsics/patchestry_intrinsics.h&gt;\n\nvoid device_security_patch(void* device) {\n    __patchestry_profile_start(\"device_security_patch\");\n\n    // Log patch entry with metadata from YAML specification\n    PATCHESTRY_INFO(\"Applying patch: %s v%s\", \n                    __patchestry_get_patch_name(),\n                    __patchestry_get_patch_version());\n\n    // Validate device with comprehensive safety checks\n    PATCHESTRY_RETURN_IF_NULL(device, -1);\n\n    if (__patchestry_device_state(device) != PATCHESTRY_DEVICE_VALID) {\n        PATCHESTRY_ERROR(\"Invalid device state\");\n        __patchestry_set_error(\"Device validation failed\");\n        return;\n    }\n\n    // Safe field modification\n    uint32_t* config = PATCHESTRY_GET_FIELD(device, config, uint32_t);\n    if (__patchestry_is_mutable(config, sizeof(uint32_t))) {\n        *config |= SECURITY_ENABLED;\n        PATCHESTRY_DEBUG(\"Security configuration updated\");\n\n        // Emit metadata for audit trail\n        __patchestry_emit_metadata(\"security_flag\", \"enabled\");\n    } else {\n        PATCHESTRY_WARN(\"Config field is immutable\");\n    }\n\n    // End profiling\n    __patchestry_profile_end(\"device_security_patch\");\n}\n</code></pre>"},{"location":"GettingStarted/intrinsic_library/#clang-ir-integration","title":"Clang IR Integration","text":"<ul> <li>Intrinsic functions will be declared as external symbols in generated IR</li> <li>Runtime library provides implementations linked at final binary creation</li> <li>Compile-time constant folding for static analysis where possible</li> </ul>"},{"location":"GettingStarted/patch_specifications/","title":"Firmware Patch Specification","text":"<p>This document outlines the specification for patching firmware binaries using a declarative YAML format. The specification applies patches at the MLIR (Multi-Level Intermediate Representation) level, specifically using Clang IR MLIR representation, allowing for architecture-independent binary modifications.</p>"},{"location":"GettingStarted/patch_specifications/#overview","title":"Overview","text":"<p>The patch specification is designed to apply patches at specific points in the decompiled MLIR representation: - Before or after function calls - At specific operations like memory loads, stores, or other operations - Replace entire functions or operations - Based on variable matching and symbolization</p> <p>By working at the MLIR level, patches can be written once and applied across multiple architectures, as the MLIR abstraction handles the architecture-specific details.</p>"},{"location":"GettingStarted/patch_specifications/#matching-types","title":"Matching Types","text":"<p>Patchestry supports two types of matching:</p> <ol> <li>Function-Based Matching: Matches and instruments entire function calls</li> <li>Operation-Based Matching: Matches and instruments specific MLIR operations within functions</li> </ol>"},{"location":"GettingStarted/patch_specifications/#function-based-vs-operation-based-matching","title":"Function-Based vs Operation-Based Matching","text":"Aspect Function-Based Operation-Based Granularity Entire function calls Individual operations (load, store, arithmetic, etc.) Match Criteria Function symbol, arguments Operation type, function context, variables Use Cases API monitoring, function replacement Memory access tracking, operation validation Required Fields <code>match.name</code> + <code>match.kind</code> <code>match.name</code> + <code>match.kind</code> Context Caller context Function containing the operation"},{"location":"GettingStarted/patch_specifications/#specification-format","title":"Specification Format","text":"<p>The patch specification is a YAML file with the following structure:</p> <pre><code>apiVersion: patchestry.io/v1             # API version\n\nmetadata:                                # Deployment metadata\n  name: \"deployment-name\"\n  description: \"Deployment description\"\n  version: \"1.0.0\"\n  author: \"Author Name\"\n  created: \"YYYY-MM-DD\"\n  organization: \"organization-name\"\n\ntarget:                                  # Target binary configuration\n  binary: \"target_binary.bin\"\n  arch: \"ARCHITECTURE:ENDIANNESS:BITWIDTH:VARIANT\"\n\nlibraries:                               # External patch and contract libraries\n  - \"path/to/library.yaml\"             # Each file may contain patches, contracts, or both\n\nexecution_order:                         # Order of patch/contract execution\n  - \"meta_patches::meta_patch_name\"\n  - \"meta_contracts::meta_contract_name\"\n\nmeta_patches:                            # Meta-patch configurations\n  - name: ...\n    description: \"...\"\n    optimization:                        # Optimization settings\n      - \"inline-patches\"\n      - \"inline-contracts\"\n    patch_actions:                       # Individual patch actions\n      - id: \"PATCH-001\"\n        description: \"...\"\n        match:                           # Match criteria\n          - name: \"...\"\n            kind: \"...\"\n            # Additional match criteria...\n        action:                          # Patch actions\n          - mode: \"...\"\n            patch_id: \"...\"\n            description: \"...\"\n            arguments:                   # Patch arguments\n              - name: \"...\"\n                source: \"...\"\n                index: \"0\"\n                is_reference: true\n\nmeta_contracts:                          # Meta-contract configurations\n  - name: ...\n    description: \"...\"\n    contract_actions:                    # Individual contract actions\n      - name: \"...\"\n        id: \"CONTRACT-001\"\n        description: \"...\"\n        match:                          # Contract match criteria\n          - name: \"...\"\n            kind: \"...\"\n          # Additional match criteria...\n        action:                         # Contract actions\n          - mode: \"...\"\n            contract_id: \"...\"\n            description: \"...\"\n            arguments:                  # Contract arguments\n              - name: \"...\"\n                source: \"...\"\n                index: 0\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#contract-types","title":"Contract Types","text":"<p>Patchestry supports two types of contracts:</p> <ol> <li>Runtime Contracts: Implemented as C/C++ functions that are called at runtime to validate conditions</li> <li>Static Contracts: Declarative specifications attached as MLIR attributes for static analysis and verification</li> </ol>"},{"location":"GettingStarted/patch_specifications/#runtime-vs-static-contracts","title":"Runtime vs Static Contracts","text":"Aspect Runtime Contracts Static Contracts Implementation C/C++ function code Declarative predicates in YAML Verification Runtime checks during execution Static analysis at compile time Performance Runtime overhead No runtime overhead Expressiveness Full programming language Limited to supported predicates Use Cases Complex validations, security checks null checks, range checks, type constraints"},{"location":"GettingStarted/patch_specifications/#field-descriptions","title":"Field Descriptions","text":""},{"location":"GettingStarted/patch_specifications/#top-level-fields","title":"Top-Level Fields","text":"Field Description Example <code>apiVersion</code> API version for the patch specification <code>\"patchestry.io/v1\"</code> <code>metadata</code> Deployment metadata container See metadata fields below <code>target</code> Target binary configuration See target fields below <code>libraries</code> External patch and contract library references See library fields below <code>execution_order</code> Order of patch/contract group execution <code>- \"meta_patches::group_name\"</code> <code>meta_patches</code> Meta-patch group configurations List of patch groups <code>meta_contracts</code> Meta-contract group configurations List of contract groups"},{"location":"GettingStarted/patch_specifications/#metadata-fields","title":"Metadata Fields","text":"Field Description Example <code>name</code> Deployment name identifier <code>\"usb-security-monitoring\"</code> <code>description</code> Deployment description <code>\"Deploy USB security monitoring\"</code> <code>version</code> Deployment version <code>\"1.0.0\"</code> <code>author</code> Author or team name <code>\"Security Team\"</code> <code>created</code> Creation date <code>\"2025-01-15\"</code>"},{"location":"GettingStarted/patch_specifications/#target-fields","title":"Target Fields","text":"Field Description Example <code>binary</code> Target binary file name <code>\"firmware.bin\"</code> <code>arch</code> Target architecture specification in format \"ARCH:ENDIANNESS:BITWIDTH\" <code>\"ARM:LE:32\"</code>"},{"location":"GettingStarted/patch_specifications/#libraries-fields","title":"Libraries Fields","text":"<p><code>libraries</code> is a list of paths to external library YAML files. Each library file may define <code>patches</code>, <code>contracts</code>, or both. Paths are resolved relative to the location of the top-level spec file.</p> <pre><code>libraries:\n  - \"patches/my_patches.yaml\"\n  - \"patches/my_contracts.yaml\"   # can also hold contracts despite the name\n</code></pre> Field Description Example <code>libraries</code> (list entry) Path to a library YAML file containing <code>patches:</code> and/or <code>contracts:</code> definitions <code>\"patches/usb_security_patches.yaml\"</code>"},{"location":"GettingStarted/patch_specifications/#meta-patch-entry-fields","title":"Meta-Patch Entry Fields","text":"Field Description Example <code>name</code> Unique identifier for the patch group <code>\"usb_security_patches\"</code> <code>description</code> Description of the patch group purpose <code>\"USB security monitoring patches\"</code> <code>optimization</code> List of optimization flags <code>[\"inline-patches\", \"inline-contracts\"]</code> <code>patch_actions</code> List of individual patch actions See patch action fields below"},{"location":"GettingStarted/patch_specifications/#meta-contract-entry-fields","title":"Meta-Contract Entry Fields","text":"Field Description Example <code>name</code> Unique identifier for the contract group <code>\"usb_control_flow_contracts\"</code> <code>description</code> Description of the contract group purpose <code>\"USB control flow integrity contracts\"</code> <code>contract_actions</code> List of individual contract actions See contract action fields below"},{"location":"GettingStarted/patch_specifications/#patch-action-fields","title":"Patch Action Fields","text":"Field Description Example <code>id</code> Unique identifier for the patch action <code>\"USB-PATCH-001\"</code> <code>description</code> Description of what the patch does <code>\"Add USB security validation\"</code> <code>match</code> List of match criteria See match fields below <code>action</code> List of actions to apply See action fields below"},{"location":"GettingStarted/patch_specifications/#contract-action-fields","title":"Contract Action Fields","text":"Field Description Example <code>id</code> Unique identifier for the contract action <code>\"USB-CONTRACT-001\"</code> <code>description</code> Description of what the contract does <code>\"Add USB control flow integrity checking\"</code> <code>match</code> List of match criteria See match fields below <code>action</code> List of actions to apply See action fields below"},{"location":"GettingStarted/patch_specifications/#match-fields","title":"Match Fields","text":"Field Description Example <code>match.name</code> Name pattern to match \u2014 a function name for <code>kind: \"function\"</code>, or an MLIR operation name (e.g. <code>\"cir.call\"</code>) for <code>kind: \"operation\"</code> <code>\"usbd_ep_write_packet\"</code>, <code>\"cir.call\"</code> <code>match.kind</code> Type of match target (<code>function</code> or <code>operation</code>) <code>\"function\"</code> <code>match.function_context</code> Functions where matches should be applied <code>name: \"/.*secure.*/\"</code> <code>match.variable_matches</code> Variables used in the operation (for function-based matching) <code>name: \"/.*password.*/\"</code> <code>match.argument_matches</code> Function arguments to match (for function-based matching) See below <code>match.symbol_matches</code> Symbols accessed by the operation (for operation-based matching) <code>name: \"/.*password.*/\"</code> <code>match.operand_matches</code> Operands to match (for operation-based matching) See below <p>Multiple match entries: Currently, only the first entry under <code>match:</code> is evaluated by the implementation. If multiple entries are provided, only the first one is used and any additional entries are ignored.</p>"},{"location":"GettingStarted/patch_specifications/#operation-based-matching","title":"Operation-Based Matching","text":"<p>Operation-based matching is supported only for patches, meaning it is not supported for contract matching and insertion. For operation-based matching, set <code>kind: \"operation\"</code> and use <code>name</code> to specify the MLIR operation name to match. The following additional fields are available:</p> Field Description Example <code>match.name</code> Required - MLIR operation name to match <code>\"cir.load\"</code>, <code>\"cir.store\"</code>, <code>\"cir.call\"</code> <code>match.kind</code> Required - must be <code>\"operation\"</code> <code>\"operation\"</code> <code>match.function_context</code> List of functions where operation should be matched <code>[{name: \"/.*secure.*/\"}]</code> <code>match.symbol_matches</code> Symbols accessed by the operation <code>[{name: \"/.*secret.*/\", type: \"!cir.ptr&lt;...&gt;\"}]</code> <code>match.operand_matches</code> Operands to match <code>[{index: 0, name: \"addr\", type: \"!cir.ptr&lt;...&gt;\"}]</code>"},{"location":"GettingStarted/patch_specifications/#function-context-fields","title":"Function Context Fields","text":"Field Description Example <code>name</code> Function name pattern (supports regex with <code>/pattern/</code>) <code>\"/.*secure.*/</code>, <code>\"authenticate\"</code>"},{"location":"GettingStarted/patch_specifications/#symbol-match-fields-operation-based-matching","title":"Symbol Match Fields  (Operation-Based Matching)","text":"Field Description Example <code>name</code> Symbol name pattern (supports regex with <code>/pattern/</code>) <code>\"/.*password.*/</code>, <code>\"secret_key\"</code> <code>type</code> Symbol type pattern (optional) <code>\"int32*\"</code>"},{"location":"GettingStarted/patch_specifications/#operand-match-fields-operation-based-matching","title":"Operand Match Fields (Operation-Based Matching)","text":"Field Description Example <code>index</code> Position of the operand (0-based) <code>0</code> (first operand), <code>1</code> (second operand) <code>name</code> Name of the operand variable <code>\"addr\"</code>, <code>\"/.*buffer.*/</code> <code>type</code> Type of the operand <code>\"int32*\"</code> <p>Common operand patterns: - <code>cir.load</code>: operand 0 = address to load from - <code>cir.store</code>: operand 0 = value to store, operand 1 = address to store to - <code>cir.binop</code>: operand 0 = left operand, operand 1 = right operand - <code>cir.call</code>: operands = function arguments</p>"},{"location":"GettingStarted/patch_specifications/#argument-match-fields-function-based-matching","title":"Argument Match Fields (Function-Based Matching)","text":"Field Description Example <code>index</code> Position of the argument (0-based) <code>1</code> <code>name</code> Name of the argument <code>\"buff\"</code> <code>type</code> Type of the argument <code>\"void*\"</code>"},{"location":"GettingStarted/patch_specifications/#variable-match-fields-function-based-matching","title":"Variable Match Fields  (Function-Based Matching)","text":"Field Description Example <code>name</code> Variable name pattern (supports regex with <code>/pattern/</code>) <code>\"/.*password.*/</code>, <code>\"secret_key\"</code> <code>type</code> Variable type pattern (optional) <code>\"struct struct_anon_struct_4_1_58265f66*\"</code>"},{"location":"GettingStarted/patch_specifications/#action-fields","title":"Action Fields","text":"Field Description Example <code>mode</code> Patching or contract mode to apply. Patch modes: <code>apply_before</code>, <code>apply_after</code>, <code>replace</code>. Contract-only mode: <code>apply_at_entrypoint</code> <code>\"apply_before\"</code> <code>patch_id</code> Reference to the patch implementation <code>\"USB-PATCH-001\"</code> <code>description</code> Description of the action being applied <code>\"Pre-validation security check\"</code> <code>arguments</code> List of arguments to pass to patch function See Argument Specification"},{"location":"GettingStarted/patch_specifications/#optimization-flags","title":"Optimization Flags","text":"<p>The <code>optimization</code> field accepts a list of optimization settings:</p> Flag Applies to Description Effect <code>\"inline-patches\"</code> <code>meta_patches</code> Inline patch function calls after insertion Reduces function call overhead <code>\"inline-contracts\"</code> <code>meta_contracts</code> Inline contract function calls after insertion Reduces contract validation overhead"},{"location":"GettingStarted/patch_specifications/#argument-specification","title":"Argument Specification","text":"<p>Arguments passed to patch or contract functions can come from different sources and are specified using a structured format that in general supports operands, function arguments, variables, and constants.</p>"},{"location":"GettingStarted/patch_specifications/#argument-structure","title":"Argument Structure","text":"<pre><code>arguments:\n  - name: \"operand_value\"\n    source: \"operand\"\n    index: 0\n  - name: \"constant_size\"\n    source: \"constant\"\n    value: \"1024\"\n  - name: \"local_var\"\n    source: \"variable\"\n    symbol: \"buffer_size\"\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#argument-fields","title":"Argument Fields","text":"Field Description Required Example <code>name</code> Descriptive name for the argument Yes <code>\"left_operand\"</code>, <code>\"store_address\"</code> <code>source</code> Where the argument comes from Yes <code>\"operand\"</code>, <code>\"argument\"</code>, <code>\"variable\"</code>, <code>\"symbol\"</code>, <code>\"constant\"</code> <code>index</code> Index for operands/arguments When <code>source</code> is <code>\"operand\"</code> or <code>\"argument\"</code> <code>0</code>, <code>1</code>, <code>2</code> <code>symbol</code> Symbol name for local variables or module-level globals/functions When <code>source</code> is <code>\"variable\"</code> or <code>\"symbol\"</code> <code>\"key_size\"</code>, <code>\"bl_spi_mode\"</code> <code>value</code> Literal value for constants When <code>source</code> is <code>\"constant\"</code> <code>\"1024\"</code>, <code>\"0x1000\"</code> <code>is_reference</code> When <code>true</code>, passes a pointer to the value instead of the value itself, allowing the patch function to mutate the caller's variable. Supported for <code>operand</code>, <code>variable</code>, and <code>symbol</code> sources. No (default: <code>false</code>) <code>true</code>, <code>false</code>"},{"location":"GettingStarted/patch_specifications/#argument-source-types","title":"Argument Source Types","text":"Source Description Required Fields Use Case <code>operand</code> (alias: <code>argument</code>) Operand or argument of the matched operation by zero-based index; <code>operand</code> and <code>argument</code> are interchangeable <code>index</code> Access operands/arguments of matched calls or operations <code>variable</code> Local variable in the enclosing function scope, located by its IR name attribute <code>symbol</code> Access local variables (alloca'd locals) in scope <code>symbol</code> Module-level global variable or function pointer, located in the module symbol table <code>symbol</code> Pass a global variable or function pointer to the patch <code>constant</code> Literal constant value <code>value</code> Pass fixed values to patch functions <code>return_value</code> Return value of function or operation None Access return value (<code>apply_before</code> / <code>apply_after</code> modes only \u2014 not valid for <code>apply_at_entrypoint</code>)"},{"location":"GettingStarted/patch_specifications/#argument-examples","title":"Argument Examples","text":""},{"location":"GettingStarted/patch_specifications/#function-call-arguments","title":"Function Call Arguments","text":"<pre><code># Validate function arguments before call\narguments:\n  - name: \"dest_ptr\"\n    source: \"argument\"\n    index: 0\n  - name: \"src_ptr\"\n    source: \"argument\"\n    index: 1\n  - name: \"max_size\"\n    source: \"constant\"\n    value: \"4096\"\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#operation-operands","title":"Operation Operands","text":"<pre><code># Check arithmetic overflow\narguments:\n  - name: \"left_val\"\n    source: \"operand\"\n    index: 0\n  - name: \"right_val\"\n    source: \"operand\"\n    index: 1\n  - name: \"overflow_limit\"\n    source: \"constant\"\n    value: \"4294967295\"\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#module-level-global-symbol","title":"Module-Level Global Symbol","text":"<pre><code># Pass a module-level global variable to the patch function\n# source: \"symbol\" looks up the name in the module symbol table (cir.GlobalOp or cir.FuncOp)\n# Use this for globals and function pointers; use source: \"variable\" for local alloca'd variables\narguments:\n  - name: \"global_var\"\n    source: \"symbol\"\n    symbol: \"bl_spi_mode\"\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#return-value-handling","title":"Return Value Handling","text":"<pre><code># Access function return value (apply_before / apply_after mode only)\n# NOTE: return_value is NOT valid for apply_at_entrypoint \u2014 the call\n# result is only defined at the matched call site, not at the function\n# entrypoint.  Use variable, symbol, or constant instead.\narguments:\n  - name: \"result\"\n    source: \"return_value\"\n  - name: \"success_code\"\n    source: \"constant\"\n    value: \"0\"\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#mixed-argument-types","title":"Mixed Argument Types","text":"<pre><code># Comprehensive validation\narguments:\n  - name: \"memory_addr\"\n    source: \"operand\"\n    index: 0\n  - name: \"buffer_size\"\n    source: \"variable\"\n    symbol: \"allocated_size\"\n  - name: \"validation_level\"\n    source: \"constant\"\n    value: \"2\"\n  - name: \"caller_func\"\n    source: \"argument\"\n    index: 2\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#complete-patch-examples","title":"Complete Patch Examples","text":""},{"location":"GettingStarted/patch_specifications/#example-1-usb-security-monitoring-deployment","title":"Example 1: USB Security Monitoring Deployment","text":"<p>While patches and contracts don't need to be used together, they can; here is an example involving both. Based on the actual specification from <code>bl_usb__send_message_before_patch.yaml</code>:</p> <pre><code>apiVersion: patchestry.io/v1\n\nmetadata:\n  name: \"usb-security-monitoring-deployment\"\n  description: \"Deploy USB security monitoring for medical device firmware\"\n  version: \"1.0.0\"\n  author: \"Security Team\"\n  created: \"2025-01-15\"\n\ntarget:\n  binary: \"medical_device_firmware.bin\"\n  arch: \"ARM:LE:32\"\n\nlibraries:\n  - \"patches/usb_security_patches.yaml\"\n\nexecution_order:\n  - \"meta_patches::usb_security_meta_patches\"\n  - \"meta_contracts::usb_security_meta_contracts\"\n\nmeta_patches:\n  - name: usb_security_meta_patches\n    description: \"Meta patches for USB security\"\n    optimization:\n      - \"inline-patches\"\n      - \"inline-contracts\"\n\n    patch_actions:\n      - id: \"USB-PATCH-001\"\n        description: \"Patch to add USB security validation\"\n        match:\n          - name: \"usbd_ep_write_packet\"\n            kind: \"function\"\n            function_context:\n              - name: \"bl_usb__send_message\"\n            argument_matches:\n              - index: 0\n                name: \"usb_g\"\n                type: \"struct struct_anon_struct_4_1_58265f66*\"\n\n        action:\n          - mode: \"replace\"\n            patch_id: \"USB-PATCH-001\"\n            description: \"Pre-validation security patch\"\n            arguments:\n              - name: \"operand_0\"\n                source: \"operand\"\n                index: \"0\"\n              - name: \"variable_2\"\n                source: \"variable\"\n                symbol: \"var1\"\n\nmeta_contracts:\n  - name: usb_security_meta_contracts\n    description: \"Contracts for USB security validation\"\n    contract_actions:\n      - id: \"USB-CONTRACTS\"\n        description: \"Assert allocation size is suitable\"\n        match:\n          - name: \"usbd_ep_write_packet\"\n            kind: \"function\"\n            function_context:\n              - name: \"bl_usb__send_message\"\n        action:\n          - mode: \"apply_before\"\n            contract_id: \"USB-CONTRACT-001\"\n            description: \"Pre-validation security contract\"\n            arguments:\n              - name: \"operand_0\"\n                source: \"operand\"\n                index: \"0\"\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#operation-based-matching-examples","title":"Operation-Based Matching Examples","text":""},{"location":"GettingStarted/patch_specifications/#example-1-monitor-sensitive-load-operations","title":"Example 1: Monitor Sensitive Load Operations","text":"<pre><code>- name: \"sensitive_loads\"\n  match:\n    - name: \"cir.load\"\n      kind: \"operation\"\n      function_context:\n        - name: \"/.*secure.*/\"  # Functions containing \"secure\"\n        - name: \"authenticate\"  # Exact function name\n      symbol_matches:\n        - name: \"/.*password.*/\"  # Variables containing \"password\"\n          type: \"int32*\"\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#example-2-match-store-operations-with-specific-operands","title":"Example 2: Match Store Operations with Specific Operands","text":"<pre><code>- name: \"validate_stores\"\n  match:\n    - name: \"cir.store\"\n      kind: \"operation\"\n      function_context:\n        - name: \"/.*critical.*/\"\n      operand_matches:\n        - index: 0  # The value being stored (first operand)\n          name: \"user_input\"\n          type: \"char*\"\n        - index: 1  # The address being stored to (second operand)\n          name: \"buffer\"\n          type: \"char[256]\"\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#pattern-matching","title":"Pattern Matching","text":"<p>Both function context and variable names support regex patterns when enclosed in forward slashes:</p> <ul> <li><code>/pattern/</code> - Regex pattern matching</li> <li><code>exact_name</code> - Exact string matching</li> </ul> <p>Examples: - <code>/.*secure.*/</code> matches functions containing \"secure\" anywhere - <code>/^test_.*/</code> matches functions starting with \"test_\" - <code>authenticate</code> matches exactly \"authenticate\"</p>"},{"location":"GettingStarted/patch_specifications/#patch-modes","title":"Patch Modes","text":"<p>The specification supports three patch modes and one contract-only mode:</p> <ul> <li><code>apply_before</code>: Apply patch or contract before the matched function or operation</li> <li><code>apply_after</code>: Apply patch or contract after the matched function or operation completes</li> <li><code>replace</code>: Completely replace the matched function call or operation (patches only)</li> <li><code>apply_at_entrypoint</code>: Insert a contract at the entry point of the caller function (contracts only \u2014 see Apply At Entrypoint Mode)</li> </ul>"},{"location":"GettingStarted/patch_specifications/#apply-before-mode","title":"Apply Before Mode","text":"<p>In <code>apply_before</code> mode, the patch is applied before the matched function or operation executes. <pre><code>action:\n  - mode: \"apply_before\"\n    patch_id: \"SECURITY-001\"\n    description: \"Pre-execution validation\"\n    arguments:\n      - name: \"input_param\"\n        source: \"operand\"\n        index: \"0\"\n      - name: \"max_size\"\n        source: \"constant\"\n        value: \"4096\"\n</code></pre></p>"},{"location":"GettingStarted/patch_specifications/#apply-after-mode","title":"Apply After Mode","text":"<p>In <code>apply_after</code> mode, the patch or contract is applied immediately after the matched function call or operation completes. For patches, this works with both function-based and operation-based matching; for contracts, <code>apply_after</code> is currently only supported with function-based (function call) matching.</p> <pre><code>action:\n  - mode: \"apply_after\"\n    patch_id: \"LOGGING-001\"\n    description: \"Post-execution logging\"\n    arguments:\n      - name: \"return_value\"\n        source: \"return_value\"\n      - name: \"execution_time\"\n        source: \"variable\"\n        symbol: \"timer_end\"\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#replace-mode","title":"Replace Mode","text":"<p>In <code>replace</code> mode, the matched function call is completely replaced by the patch function. The original code is not executed. When used with operation-based matching, the target operation must be a <code>cir.call</code> \u2014 attempting to replace other operation types (e.g., <code>cir.store</code>) will log an error and leave the operation unchanged.</p> <pre><code>action:\n  - mode: \"replace\"\n    patch_id: \"SECURE-REPLACEMENT-001\"\n    description: \"Secure function replacement\"\n    arguments:\n      - name: \"original_arg1\"\n        source: \"operand\"\n        index: \"0\"\n      - name: \"original_arg2\"\n        source: \"operand\"\n        index: \"1\"\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#apply-at-entrypoint-mode","title":"Apply At Entrypoint Mode","text":"<p><code>apply_at_entrypoint</code> is a contract-only mode that inserts the contract call at the beginning of the caller function \u2014 the function that contains the matched call \u2014 rather than at the matched call site itself.</p> <p>Important: The name can be misleading. The contract is not inserted at the beginning of the matched function (the callee). It is inserted at the beginning of the enclosing function (the caller) that was specified in <code>function_context</code>. Insertion happens after all <code>cir.alloca</code> ops and parameter-initialization stores so that all of the caller's parameters are in scope.</p> <p>When to use it: When you want to validate invariants at function entry using the caller's local parameters, before any call inside the function executes.</p> <p>How it works (example): - <code>match.name</code> = <code>\"usbd_ep_write_packet\"</code> \u2014 the call to find inside the caller - <code>match.function_context.name</code> = <code>\"bl_usb__send_message\"</code> \u2014 the caller whose entry point receives the contract - The contract call is inserted at the start of <code>bl_usb__send_message</code>, not at the <code>usbd_ep_write_packet</code> call site - Arguments (e.g., <code>source: \"variable\"</code>) are resolved from <code>bl_usb__send_message</code>'s local scope</p> <pre><code>contract_actions:\n  - id: \"ENTRY-CONTRACT-001\"\n    description: \"Null-check message pointer at function entry\"\n\n    match:\n      - name: \"usbd_ep_write_packet\"   # call to find inside the caller\n        kind: \"function\"\n        function_context:\n          - name: \"bl_usb__send_message\"  # contract inserts HERE, at this function's entry\n\n    action:\n      - mode: \"apply_at_entrypoint\"\n        contract_id: \"message_entry_check_contract\"\n        description: \"Runtime null-check on message pointer at bl_usb__send_message entry\"\n        arguments:\n          # source: variable \u2014 load a named local/parameter alloca at entry\n          - name: \"msg\"\n            source: \"variable\"\n            symbol: \"msg\"\n          # source: operand \u2014 index 0 maps to the 0th argument of bl_usb__send_message,\n          # not the 0th operand of the usbd_ep_write_packet call\n          - name: \"usb_handle\"\n            source: \"operand\"\n            index: 0\n</code></pre> <p>Note: The contract is inserted at the beginning of the caller (<code>bl_usb__send_message</code> \u2014 the function containing the matched call), not at the beginning of the matched function itself (<code>usbd_ep_write_packet</code>).</p>"},{"location":"GettingStarted/patch_specifications/#contract-library-specification","title":"Contract Library Specification","text":"<p>Contract libraries are separate YAML files that define reusable contracts. They can be referenced by multiple deployment specifications.</p>"},{"location":"GettingStarted/patch_specifications/#contract-library-structure","title":"Contract Library Structure","text":"<pre><code>apiVersion: patchestry.io/v1\n\nmetadata:\n  name: \"contract-library-name\"\n  version: \"1.0.0\"\n  description: \"Description of contract library\"\n  author: \"Author Name\"\n  created: \"YYYY-MM-DD\"\n\ncontracts:\n  - name: \"contract_name\"\n    description: \"Contract description\"\n    category: \"validation_category\"\n    severity: \"critical|high|medium|low\"\n    type: \"STATIC|RUNTIME\"\n\n    # For STATIC contracts\n    preconditions: [...]\n    postconditions: [...]\n\n    # For RUNTIME contracts\n    function_name: ...\n    code_file: ...\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#contract-library-fields","title":"Contract Library Fields","text":"Field Description Required Example <code>apiVersion</code> API version Yes <code>\"patchestry.io/v1\"</code> <code>metadata</code> Library metadata Yes See metadata fields <code>contracts</code> List of contract specifications Yes See contract spec fields"},{"location":"GettingStarted/patch_specifications/#contract-specification-fields","title":"Contract Specification Fields","text":"Field Description Required Type Example <code>name</code> Contract identifier Yes All <code>\"usb_validation_contract\"</code> <code>description</code> Contract description No All <code>\"Validates USB parameters\"</code> <code>category</code> Contract category No All <code>\"validation\"</code>, <code>\"security\"</code> <code>severity</code> Severity level No All <code>\"critical\"</code>, <code>\"high\"</code>, <code>\"medium\"</code>, <code>\"low\"</code> <code>type</code> Contract type Yes All <code>\"STATIC\"</code> or <code>\"RUNTIME\"</code> <code>preconditions</code> Static preconditions STATIC only STATIC List of precondition specs <code>postconditions</code> Static postconditions STATIC only STATIC List of postcondition specs <code>function_name</code> Runtime contract function name RUNTIME only RUNTIME Implementation details <code>code_file</code> Runtime contract implementation file RUNTIME only RUNTIME Implementation details"},{"location":"GettingStarted/patch_specifications/#static-contract-predicates","title":"Static Contract Predicates","text":"<p>Static contracts use declarative predicates that are attached as MLIR attributes. Each predicate specifies a condition that must hold.</p>"},{"location":"GettingStarted/patch_specifications/#predicate-structure","title":"Predicate Structure","text":"<pre><code>preconditions:\n  - id: \"precondition_1\"\n    description: \"Description of the precondition\"\n    pred:\n      kind: \"nonnull|relation|alignment|expr|range\"\n      # Fields depend on kind - see \"Predicate Kind Requirements\" below\n      target: \"arg0|arg1|...|return_value|symbol\"  # Required for: nonnull, relation, range\n      relation: \"eq|neq|lt|lte|gt|gte|none\"        # Required for: relation\n      value: \"constant_value\"                      # Required for: relation\n      symbol: \"symbol_name\"                        # Optional: descriptive symbol name\n      align: \"alignment_bytes\"                     # Required for: alignment\n      expr: \"expression_string\"                    # Required for: expr\n      range:                                       # Required for: range\n        min: \"min_value\"\n        max: \"max_value\"\n\npostconditions:\n  - id: \"postcondition_1\"\n    description: \"Description of the postcondition\"\n    pred:\n      # Same structure as preconditions\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#static-contract-predicate-fields","title":"Static Contract Predicate Fields","text":"Field Description Required Example <code>id</code> Unique identifier for the condition Yes <code>\"precondition_1\"</code> <code>description</code> Human-readable description No <code>\"Ensure pointer is non-null\"</code> <code>pred</code> Predicate specification Yes See predicate fields below"},{"location":"GettingStarted/patch_specifications/#predicate-fields","title":"Predicate Fields","text":"Field Description Required Valid Values Example <code>kind</code> Type of predicate Yes <code>nonnull</code>, <code>relation</code>, <code>alignment</code>, <code>expr</code>, <code>range</code> <code>\"relation\"</code> <code>target</code> What the predicate applies to <code>nonnull</code>, <code>relation</code>, <code>range</code> <code>arg0</code>, <code>arg1</code>, ..., <code>return_value</code>, <code>symbol</code> <code>\"arg0\"</code> <code>relation</code> Comparison relation <code>relation</code> only <code>eq</code>, <code>neq</code>, <code>lt</code>, <code>lte</code>, <code>gt</code>, <code>gte</code>, <code>none</code> <code>\"neq\"</code> <code>value</code> Constant value for comparison <code>relation</code> only String representation of value <code>\"0\"</code>, <code>\"NULL\"</code> <code>symbol</code> Symbol name reference (descriptive) If target is symbol Symbol name <code>\"usb_device\"</code> <code>align</code> Alignment requirement in bytes <code>alignment</code> only String representation of bytes <code>\"4\"</code>, <code>\"8\"</code> <code>expr</code> Expression string <code>expr</code> only Expression string <code>\"usb_device != NULL\"</code> <code>range</code> Range constraint <code>range</code> only Range object See range fields"},{"location":"GettingStarted/patch_specifications/#range-fields","title":"Range Fields","text":"Field Description Example <code>min</code> Minimum value (inclusive) <code>\"0\"</code> <code>max</code> Maximum value (inclusive) <code>\"USB_MAX_PACKET_SIZE\"</code>"},{"location":"GettingStarted/patch_specifications/#predicate-kinds-and-required-fields","title":"Predicate Kinds and Required Fields","text":"<p>Each predicate kind requires specific fields. Only include the fields listed for each kind to avoid parser errors:</p> Kind Description Required Fields Optional Fields Example Use Case <code>nonnull</code> Assert target is not null <code>kind</code>, <code>target</code> <code>symbol</code> Null pointer guard <code>relation</code> Compare target against a value <code>kind</code>, <code>target</code> (arg, return_value, or symbol), <code>relation</code>, <code>value</code> <code>symbol</code> Bounds checking, comparisons <code>alignment</code> Verify memory alignment <code>kind</code>, <code>target</code>, <code>align</code> <code>symbol</code> Memory alignment requirements <code>expr</code> Free-form expression <code>kind</code>, <code>expr</code> <code>target</code>, <code>symbol</code> Complex conditions <code>range</code> Verify value is within range <code>kind</code>, <code>target</code> (arg, return_value, or symbol), <code>range</code> (with <code>min</code> and <code>max</code>) <code>symbol</code> Input validation, bounds"},{"location":"GettingStarted/patch_specifications/#quick-reference-field-requirements-by-predicate-kind","title":"Quick Reference: Field Requirements by Predicate Kind","text":"Predicate Kind <code>kind</code> <code>target</code> <code>relation</code> <code>value</code> <code>align</code> <code>expr</code> <code>range</code> <code>symbol</code> nonnull \u2713 \u2713 \u2717 \u2717 \u2717 \u2717 \u2717 Optional relation \u2713 \u2713 \u2713 \u2713 \u2717 \u2717 \u2717 Optional alignment \u2713 \u2713 \u2717 \u2717 \u2713 \u2717 \u2717 Optional expr \u2713 Optional \u2717 \u2717 \u2717 \u2713 \u2717 \u2717 range \u2713 \u2713 \u2717 \u2717 \u2717 \u2717 \u2713 Optional <p>Legend: \u2713 = Required, \u2717 = Not allowed/Not used, Optional = May be included</p> <p>Important Notes: - <code>nonnull</code>: Only requires <code>target</code> (e.g., <code>arg0</code>). Asserts the target pointer is not null. No other fields are used. - <code>relation</code>: Must specify <code>target</code>, <code>relation</code> operator, and <code>value</code> to compare against. Target can be an argument, return value, or symbol reference. - <code>alignment</code>: Must specify <code>target</code> and <code>align</code> (alignment in bytes). Typically used with pointer arguments. - <code>expr</code>: Only requires the <code>expr</code> field with a free-form expression string. Target and symbol are optional for context. - <code>range</code>: Must specify <code>target</code> and a <code>range</code> object with both <code>min</code> and <code>max</code> values. - <code>symbol</code>: This field is always optional and serves as a descriptive reference to document what variable or symbol the predicate refers to.</p>"},{"location":"GettingStarted/patch_specifications/#target-specification","title":"Target Specification","text":"<p>The <code>target</code> field specifies what the predicate applies to:</p> <ul> <li><code>arg0</code>, <code>arg1</code>, etc.: Function arguments (0-indexed)</li> <li><code>return_value</code>: Return value of the function</li> <li><code>symbol</code>: A named symbol (requires <code>symbol</code> field)</li> </ul>"},{"location":"GettingStarted/patch_specifications/#relation-types","title":"Relation Types","text":"<p>For <code>relation</code> kind predicates:</p> Relation Operators Description <code>eq</code> <code>==</code> Equal to <code>neq</code> <code>!=</code> Not equal to <code>lt</code> <code>&lt;</code> Less than <code>lte</code> <code>&lt;=</code> Less than or equal to <code>gt</code> <code>&gt;</code> Greater than <code>gte</code> <code>&gt;=</code> Greater than or equal to <code>none</code> - No relation (for existence checks)"},{"location":"GettingStarted/patch_specifications/#static-contract-examples","title":"Static Contract Examples","text":""},{"location":"GettingStarted/patch_specifications/#example-1-null-pointer-guard-nonnull","title":"Example 1: Null Pointer Guard (nonnull)","text":"<pre><code>preconditions:\n  - id: \"ptr_nonnull\"\n    description: \"First argument must not be null\"\n    pred:\n      kind: \"nonnull\"\n      target: \"arg0\"\n      symbol: \"dest\"  # Optional: for documentation\n</code></pre> <p>Required fields for <code>nonnull</code>: <code>kind</code>, <code>target</code></p>"},{"location":"GettingStarted/patch_specifications/#example-2-range-validation-range","title":"Example 2: Range Validation (range)","text":"<pre><code>preconditions:\n  - id: \"size_range\"\n    description: \"Buffer size must be within valid range\"\n    pred:\n      kind: \"range\"\n      target: \"arg1\"\n      range:\n        min: \"0\"\n        max: \"USB_MAX_PACKET_SIZE\"\n      symbol: \"buffer_size\"  # Optional: for documentation\n</code></pre> <p>Required fields for <code>range</code>: <code>kind</code>, <code>target</code>, <code>range</code> (with <code>min</code> and <code>max</code>)</p>"},{"location":"GettingStarted/patch_specifications/#example-3-comparison-relation-relation","title":"Example 3: Comparison Relation (relation)","text":"<pre><code>preconditions:\n  - id: \"size_positive\"\n    description: \"Size must be greater than zero\"\n    pred:\n      kind: \"relation\"\n      target: \"arg1\"\n      relation: \"gt\"\n      value: \"0\"\n      symbol: \"size\"  # Optional: for documentation\n</code></pre> <p>Required fields for <code>relation</code>: <code>kind</code>, <code>target</code>, <code>relation</code>, <code>value</code></p>"},{"location":"GettingStarted/patch_specifications/#example-4-memory-alignment-alignment","title":"Example 4: Memory Alignment (alignment)","text":"<pre><code>preconditions:\n  - id: \"buffer_aligned\"\n    description: \"Buffer must be 4-byte aligned\"\n    pred:\n      kind: \"alignment\"\n      target: \"arg0\"\n      align: \"4\"\n      symbol: \"buffer\"  # Optional: for documentation\n</code></pre> <p>Required fields for <code>alignment</code>: <code>kind</code>, <code>target</code>, <code>align</code></p>"},{"location":"GettingStarted/patch_specifications/#example-5-complex-expression-expr","title":"Example 5: Complex Expression (expr)","text":"<pre><code>preconditions:\n  - id: \"device_valid\"\n    description: \"USB device must be in configured state\"\n    pred:\n      kind: \"expr\"\n      expr: \"usb_device-&gt;state == USB_STATE_CONFIGURED\"\n</code></pre> <p>Required fields for <code>expr</code>: <code>kind</code>, <code>expr</code> Optional fields: <code>target</code>, <code>symbol</code> (for documentation)</p>"},{"location":"GettingStarted/patch_specifications/#example-6-return-value-check-relation","title":"Example 6: Return Value Check (relation)","text":"<pre><code>postconditions:\n  - id: \"success_return\"\n    description: \"Function must return success code\"\n    pred:\n      kind: \"relation\"\n      target: \"return_value\"\n      relation: \"eq\"\n      value: \"0\"\n</code></pre> <p>Required fields for <code>relation</code> on return value: <code>kind</code>, <code>target</code> (set to <code>return_value</code>), <code>relation</code>, <code>value</code></p>"},{"location":"GettingStarted/patch_specifications/#complete-static-contract-example","title":"Complete Static Contract Example","text":"<p>This example demonstrates all predicate kinds with correct field usage:</p> <pre><code>apiVersion: patchestry.io/v1\n\nmetadata:\n  name: \"usb-security-contracts\"\n  version: \"1.0.0\"\n  description: \"USB security contracts for medical devices\"\n  author: \"Security Team\"\n  created: \"2025-01-15\"\n\ncontracts:\n  - name: \"usb_endpoint_write_validation\"\n    description: \"Validate USB endpoint write parameters\"\n    category: \"write_validation\"\n    type: \"STATIC\"\n\n    preconditions:\n      # Example 1: range predicate\n      - id: \"size_range\"\n        description: \"Write size must be within valid range\"\n        pred:\n          kind: \"range\"\n          target: \"arg2\"\n          range:\n            min: \"1\"\n            max: \"USB_MAX_PACKET_SIZE\"\n\n      # Example 2: alignment predicate\n      - id: \"buffer_aligned\"\n        description: \"Buffer must be properly aligned\"\n        pred:\n          kind: \"alignment\"\n          target: \"arg1\"\n          align: \"4\"\n\n    postconditions:\n      # Example 3: relation predicate on return value\n      - id: \"return_success\"\n        description: \"Function must return success or error code\"\n        pred:\n          kind: \"relation\"\n          target: \"return_value\"\n          relation: \"gte\"\n          value: \"-1\"\n\n      # Example 4: expr predicate\n      - id: \"state_valid\"\n        description: \"Device state must remain valid\"\n        pred:\n          kind: \"expr\"\n          expr: \"usb_device-&gt;state != USB_STATE_ERROR\"\n          # Note: target and symbol are optional for expr predicates\n</code></pre> <p>Summary of field usage by predicate kind: - nonnull: <code>kind</code> + <code>target</code> (<code>arg&lt;N&gt;</code>, <code>return_value</code>, or <code>symbol</code>) - relation: <code>kind</code> + <code>target</code> + <code>relation</code> + <code>value</code> (<code>arg&lt;N&gt;</code>, <code>return_value</code>, or <code>symbol</code>) - alignment: <code>kind</code> + <code>target</code> + <code>align</code> (<code>arg&lt;N&gt;</code>, <code>return_value</code>, or <code>symbol</code>) - expr: <code>kind</code> + <code>expr</code> - range: <code>kind</code> + <code>target</code> + <code>range</code> (with <code>min</code>/<code>max</code>) (<code>arg&lt;N&gt;</code>, <code>return_value</code>, or <code>symbol</code>)</p>"},{"location":"GettingStarted/patch_specifications/#runtime-contract-implementation","title":"Runtime Contract Implementation","text":"<p>For runtime contracts, specify the implementation details:</p> <pre><code>contracts:\n  - name: \"usb_endpoint_write_contract\"\n    description: \"Runtime validation for USB endpoint write\"\n    type: \"RUNTIME\"\n\n    code_file: \"contracts/usb_validation.c\"\n    function_name: \"contract::usb_endpoint_write_validation\"\n    parameters:\n      - name: \"usb_device\"\n        type: \"usb_device_t*\"\n        description: \"USB device context\"\n      - name: \"buffer\"\n        type: \"const void*\"\n        description: \"Data buffer\"\n      - name: \"size\"\n        type: \"uint32_t\"\n        description: \"Buffer size\"\n</code></pre>"},{"location":"GettingStarted/patch_specifications/#deployment-architecture","title":"Deployment Architecture","text":"<p>The meta-patch architecture allows for:</p> <ol> <li>Modular Organization: Group related patches into logical units</li> <li>External Libraries: Reference shared patch and contract libraries</li> <li>Execution Ordering: Control the order of patch application</li> <li>Optimization Control: Fine-tune performance characteristics</li> <li>Exclusion Patterns: Exclude specific functions from patching</li> </ol>"}]}