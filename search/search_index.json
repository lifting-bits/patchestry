{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MLIR-based binary patching framework","text":"<p>Patchestry aims to make the same impact to binary patching as compilers and high level languages did to early software development. Its main goal is to enable developers without extensive knowledge of the deployment platform of the binary to patch the binary. To do this, the developer has to be confident that what they're patching is functionally equivalent to what is deployed and also that the patch they write will integrate into the deployed binary without issue.</p> <p>Patchestry leverages MLIR as the foundational technology instead of LLVM IR. MLIR is an emerging compiler development technology allowing for the specification, transformation, and mixing of IR dialects. The MLIR approach has significant industry momentum, and has been adopted by companies such as Google (in TensorFlow) and Meta (ClangIR). With MLIR, the decompilation process could be stratified into a Tower of IRs (IR dialects). Each IR represents the same program, but at a different level of abstraction.</p> <p>MLIR brings a notable advantage by enabling the creation of representations to streamline communication between diverse state-of-the-art tools. For instance, one can create an MLIR dialect specifically for P-Code (a program representation utilized by Ghidra) to optimize integration with the Ghidra decompiler. Alternatively, an LLVM IR dialect can be employed to compile back to the executable, and MLIR can support LLVM-based contract validation through a symbolic executor such as KLEE. Moreover, MLIR provides flexibility to devise our own dialects for representing contracts in specialized logic, such as SMT. Finally, our high-level dialect, developed under DARPA V-SPELLS, captures the intricacies of full-featured C. Our compiler stacks empower us to compile C into any of the previously mentioned representations, promoting seamless interconnection between them.</p>"},{"location":"#technical-rationale","title":"Technical Rationale","text":"<p>Our recent experience on AMP, as well as our performance on other DARPA binary analysis programs (PACE, CFAR, LOGAN, CGC, Cyber Fast Track), have led us to four guiding principles that we believe patching solutions for legacy software must follow in order to be successful.</p> <ol> <li> <p>Fully automated approaches are doomed to failure. In general, the process of decompilation is an inherently intractable problem. However, developers are often capable of distinguishing between decompilation outcomes deemed 'good' or 'bad', but encoding that kind of heuristic logic into a system invariably yields unpredictability and unsoundness.  Hence, we assert that the involvement of semi-skilled or skilled human developers is essential in the process. The best-case scenario is that a developer can use an existing source code patch as a guide. Given this patch, they can locate the corresponding vulnerable machine code within a binary using binary function symbol names. The worst-case scenario involves the ad hoc application of tools (e.g. BinDiff, BSim) and reverse engineering skills to an opaque binary blob that is without symbols or debugging information.</p> </li> <li> <p>Developers must be able to leverage pre-existing software development experience and not have to concern themselves with low level details. That is, they should be able to operate as if the original source code and build process/environments were available, and not be expected to have expert knowledge of every machine code language that may be encountered.</p> </li> <li> <p>From-scratch development efforts do not scale. As much as possible, pre-existing tooling that already handles the inherent scalability challenges in (de)compiling code for such a wide variety of platforms should be leveraged. For example the Ghidra decompiler can decompile over 100 machine code languages to C, and the Clang compiler can generate machine code for over 20 machine code languages. Rolling new solutions from scratch is impractical.</p> </li> <li> <p>There is no one-size-fits-all way of representing code. A \u201ccomplete\u201d solution to machine code decompilation only exists at the end of a long tail of special cases. Patchestry aims to provide decompilation to a familiar, C-like language. Patchestry will not, however, decompile to C or a specific ISO dialect thereof because some machine code constructs have no equivalents in C, while others are only loosely equivalent given non-conforming dialect extensions.</p> </li> </ol>"},{"location":"#project-goals","title":"Project Goals","text":"<p>Patchestry accomplishes its goals by integrating various innovative concepts guided by the four principles described in technical rationale:</p>"},{"location":"#unified-tooling-integration","title":"Unified Tooling Integration","text":"<p>Guided by the third principle\u2014recognizing the limitations of from-scratch development efforts\u2014Patchestry seamlessly integrates existing tooling for decompilation and recompilation in the binary patching process. Patchestry advocates a unified tooling integration approach using an MLIR Tower of Intermediate Representations (IRs) as a mediator between tools. This strategy enables the incorporation of cutting-edge (de)compiler tools into a cohesive system, allowing the utilization of specialized tools for each task and ensuring effectiveness and optimal outcomes across all desired functionalities.</p>"},{"location":"#incremental-decompilation","title":"Incremental Decompilation","text":"<p>Patchestry\u2019s innovative approach involves leveraging multiple program representations simultaneously across various layers of the Tower of IRs. While state-of-the-art decompilers already offer diverse representations, what sets the Tower of IRs apart is its capability to create custom user-defined abstractions (layers) while preserving relationships between these layers. This modular approach facilitates seamless incremental decompilation and recompilation processes. This is crucial for effortlessly devising specific abstractions tailored to unique platforms.</p>"},{"location":"#unifying-representations-for-contracts-patches-and-software","title":"Unifying Representations for Contracts, Patches, and Software","text":"<p>The Tower of IRs also aligns with the fourth guiding principle: There is no one-size-fits-all way of representing code.  Maintaining multiple representations simultaneously in the Tower of IRs allows us to establish meaningful relationships between them and innovate in how we connect tools and conduct analyses. Additionally, this approach allows us to consolidate all necessary components for patching within the same representation: patch description, contract description and the software. This unified strategy streamlines tooling for analysis and facilitates the recompilation of patched software, resulting in a single artifact that can undergo desired formal analyses, such as LLVM-based analysis.</p>"},{"location":"#declarative-patching-and-contracts-description","title":"Declarative Patching and Contracts Description","text":"<p>To address our second guiding principle, which emphasizes the importance of allowing developers to leverage their existing software development experience, we mandate that all interactions with patching occur in a language commonly understood by developers. Specifically, a C-like language. To facilitate this, we propose a declarative library designed for describing patches, their application. Following the same principle, Patchestry introduces contracts in C-like DSL. These contracts serve as constraints guiding both decompilation and recompilation, and they must hold at all relevant steps of each process.</p>"},{"location":"#decompilation-workflow","title":"Decompilation Workflow","text":"<p>Patchestry\u2019s technical approach is designed to enable the following seven-step workflow:</p> <ol> <li> <p>A developer is tasked with patching a vulnerability in a program binary running on a device. How the user acquires a copy of the binary (e.g. downloaded from a vendor\u2019s website, extracted from a network capture, extracted directly from a device over serial port or JTAG, etc.) is not part of the project.</p> </li> <li> <p>The developer loads the binary into the open-source Ghidra interactive decompiler. Developers will be enabled to leverage Ghidra\u2019s features and plugins to locate the function(s) to patch, though previous binary analysis expertise is not required. We anticipate that developers will apply tools such as BinDiff or BSim, rely on symbol names or debug information, or apply reverse engineering techniques.</p> </li> </ol> <p>The Patchestry workflow includes Ghidra because it is open-source and actively maintained by the National Security Agency and because it supports a wide variety of binary file formats (ELF, COFF, PE, etc.) and machine code languages used by medical devices. Ghidra also implements a battery of heuristics that act as good first guesses as to the locations and references between functions and data in the binary. Although perfect identification/recovery of functions, data, and data types in a binary is intractable, the value of interactivity in Ghidra is that the human developer can fix incorrect conclusions drawn by the decompiler\u2019s heuristics.</p> <p>There are two reasons why Patchestry\u2019s workflow does not allow the developer to modify Ghidra\u2019s decompilation output and then re-compile that into a patchable representation. First, Ghidra\u2019s decompilation is not guaranteed to be syntactically correct or compilable. This can be mitigated through developer effort; however, the level of effort increases with the complexity of and number of references in the target function(s). Second, Ghidra\u2019s heuristic decompilation pipeline has been proven to be unfaithful with respect to the execution semantics of the machine code. In the worst case, this could result in a developer inadvertently introducing new vulnerabilities into the program during the patching process.</p> <p>Despite Ghidra\u2019s decompilation not being precise enough for recompilation, our experience from AMP tells us that Ghidra\u2019s decompilation is good enough to be a productivity multiplier for developers trying to locate functions that need patching.</p> <p>Moreover, the modular design of Patchestry affords the flexibility to seamlessly integrate more formally rigorous decompilers and their representations in the future, as their capabilities align with our technical requirements. Currently, the majority of existing tools are predominantly of a research-oriented nature, often concentrating on x86 architecture or even just its subset, which is not sufficient for the diverse nature of software.</p> <ol> <li>After locating the relevant function(s) in Ghidra, the Patchestry plugin will present the developer with an editable decompilation of the target function(s). Patchestry\u2019s decompilations will be sound and precise with respect to the available information in Ghidra\u2019s analysis database. Regardless of how small the patch size could be, Patchestry will always formulate the problem at the function granularity. There are theoretical and pragmatic reasons why Patchestry\u2019s minimum patch recompilation granularity is function-at-a-time.</li> </ol> <p>From a theoretical standpoint, function granularity patches enable Patchestry to leverage stronger guarantees about the application binary interface (ABI). It is only at the entry and exit points of a compiled function that higher-level, human-readable types can be reliably mapped to low level machine locations (registers, memory).</p> <p>Patchestry leverages the open-source Clang compiler, which can already target relevant platforms. A restriction in compilers like Clang that nonetheless favors our approach is that functions are the smallest compilable unit of code. Our task in Patchestry is thus to convert code for recompilation into LLVM IR functions, which Clang can convert to machine code.</p> <ol> <li>The developer edits the decompiled function(s), enacting the necessary changes to patch the vulnerability in the decompiled code. Patchestry\u2019s highest level decompiled code (C-like) will look approximately similar, regardless of the platform/architecture of the medical device software. This will help improve developer productivity. Moreover, the meta-patch library will allow the developer to automate the patching process.</li> </ol> <p>At this stage, the binary-level patch has not yet been formulated. What particular changes are needed to patch a given vulnerability are beyond the scope of the project and require an external tool. Patchestry will, however, provide a library of \u201cpatch intrinsics\u201d such as \u201cadd bounds check.\u201d These will be formulated as templates of meta-patches.</p> <p>A developer can make near arbitrary changes within the body of the decompiled code (e.g. add, remove or replace its portions). Although Patchestry aims to provide verifiable guarantees about feature- and bug-compatibility of its decompilation with respect to the Ghidra database, absent contracts or specifications about the intended behavior of the code, Patchestry cannot make guarantees about the correctness of the edited decompilation. That is, Patchestry cannot prevent a developer from introducing new flaws into the binary, nor can it guarantee that a patch comprehensively fixes the root cause of the vulnerability.</p> <p>To mitigate the problem of developer- or decompiler-introduced emergent behaviors, Patchestry will allow developers to leverage model- and contract-based software verification techniques. These techniques are normally challenging to apply to lifting/decompilation due to a lack of end-to-end visibility into the lifting process; usually the techniques only apply at the very last stage, on the decompiled/lifted result. However, Patchestry\u2019s approach to decompilation is multi-level: decompilation progresses through a stage of increasingly high-level IRs. By taking a multi-level approach, Patchestry can instrument contracts at various stages of the process.</p> <ol> <li> <p>Verification of contracts. To ensure the reliability of patched code along with associated contracts, Patchestry offers a toolset for generating output compatible with both static and dynamic analysis tools. The optimal choice for this purpose is LLVM IR, given its verification confirms the fulfillment of contracts before its compilation. Patchestry allows for easy integration of LLVM-based analysis tools such as KLEE or SeaHorn, automating the verification process.</p> </li> <li> <p>Patchestry formulates the patch by compiling developer-edited decompiled function(s), and packages the patch for use by a binary patching tool. Patchestry will utilize a pre-existing tool, such as Patcherex or OFRAK, to enact the patch process, creating a new version of the binary.</p> </li> <li> <p>Finally, the developer will load the new version of the binary onto the device. How the developer loads the new version of the binary is not part of the project.</p> </li> </ol>"},{"location":"#architecture","title":"Architecture","text":"<p>The Patchestry design places a strong emphasis on modularity and seamless developer interaction. The developer plays a key role, providing the binary pieces to be patched, a patch description, and instructions on how to apply these patches using the meta-programming framework (meta-patches). Contracts are similarly specified and applied by instrumentation using the same meta-language. Utilizing state-of-the-art tools, we perform decompilation and program analysis.</p> <p>A significant architectural innovation is the MLIR Tower of IRs, which serves as the connecting element. This tower facilitates the association of representations between decompiled programs, such as from P-Code and compilable and structured representations like LLVM IR. The tower's modularity allows for the specification of any DSL for the decompiled program, with the only requirement being the translation of this DSL to a layer of the tower. In our case, Ghidra's P-Code serves as a suitable starting point layer. However, this modular design allows new decompilers to be integrated into Patchestry in the future while preserving the rest of the architecture.</p> <p>Utilizing the same representation (MLIR dialects) for both the decompiled binary and the compiled patched version facilitates seamless instrumentation and inlining of patches, ultimately producing a patched MLIR (Tower of IRs). The tower's various abstraction layers enable precise specification of points of interest, surpassing the limitations of a single representation. Additionally, the tower abstracts away from the decompiled representation (P-Code), facilitating modular design in the future.</p> <p>Contract handling follows a similar pattern. Described in a C-like language, contracts can take the form of static or runtime assertions or error handlers. These are inserted into the code while it is in the IR Tower form. Runtime checks are then compiled and remain in the patched binary. Static contracts are checked using a formal verifier. The flexibility to invent new contract mechanisms according to specific needs is a key feature.</p> <p>In the verification phase, which is the final step, Patchestry is designed to accommodate various verification methods. The Tower allows to produce a customized representation for the analysis, but it is advisable to stick to the same representation as the compilation (such as LLVM IR) to prevent errors during translation. Slicing the codebase into independent parts influenced by the patch makes LLVM-based static analysis of the representation with contracts tractable. We expect that most of the patches being local influence only a small part of the program, therefore using the dependency analysis, we can isolate the part of the program that needs to be verified.</p>"},{"location":"#cve-2021-22156-patching","title":"CVE-2021-22156 Patching","text":"<p>An example of patching the CVE-2021-22156 vulnerability, addressing an integer overflow within the <code>calloc()</code> function of the C standard library. This vulnerability affects versions of the BlackBerry QNX Software Development Platform (SDP) up to version 6.5.0SP1, QNX OS for Medical up to version 1.1, and QNX OS for Safety up to version 1.0.1. A malicious actor could exploit this integer overflow issue to execute arbitrary code or initiate a denial of service attack.</p> <p>Consider the vulnerable code snippet below. Here, a user-defined function, <code>get_num_elements()</code>, is employed to determine the size requirements for a dynamic array of long integers assigned to the variable num_elements. During the allocation of the buffer using <code>calloc()</code>, the variable num_elements is multiplied by sizeof(long) to calculate the overall size requirements. If the resulting multiplication exceeds the representable range of <code>size_t</code>, <code>calloc()</code> may allocate a zeroed buffer of insufficient size. Subsequently, when data is copied into this buffer, an overflow may occur, posing a potential security risk.</p> <p>A vulnerable code in which the standard library function <code>calloc()</code> may allocate a zeroed buffer of insufficient size:</p> <pre><code>size_t num_elements = get_num_elements(); // from the outside environment\n\nlong *buffer = (long *)calloc(num_elements, sizeof(long));\n\nif (buffer == NULL) {\n    /* Handle error condition */\n}\n</code></pre> <p>The desired result of applying Patchestry to fix the vulnerable code:</p> <pre><code>size_t num_elements = get_num_elements(); // from the outside environment\n\n/* Patch start */\nif (num_elements &gt; SIZE_MAX/sizeof(long)) {\n    /*  Handle error condition */\n}\n/* Patch end */\n\nlong *buffer = (long *)calloc(num_elements, sizeof(long));\nif (buffer == NULL) {\n    /* Handle error condition */\n    return;\n}\n</code></pre> <p>To create this simple patch, we require two essential components: the patch itself and the specific locations where the patch should be applied. In Patchestry, we offer developers a library, allowing them to articulate these components using familiar C-like syntax:</p> <pre><code>// 1. Patch in C\n[[CVE-2021-22156]] void patch(size_t num_elements) {\n    if (num_elements &gt; SIZE_MAX/sizeof(long)) {\n            /*  Handle error condition  */\n    }\n}\n\n// 2. Developer-defined meta-patch transformation\nvoid meta_patch(source_module_t module) {\n    for (const callsite_t &amp;place : module.calls(\"calloc\")) {\n        place.apply_before(\"CVE-2021-22156::patch\", { place.operand(1) });\n    }\n}\n</code></pre> <p>Patchestry introduces a metaprogramming interface enabling  developer-defined code transformations. Patchestry\u2019s interface supports common patching operations such as code insertion, replacement, alteration, and deletion. To obtain the source module from the program binary, we leverage state-of-the-art decompilers and seamlessly integrate them into the MLIR source representation, as elaborated later. Patchestry\u2019s source representation can be modified and queried through the metaprogramming API.</p> <p>The second crucial aspect of Patchestry involves providing assurances regarding patches. Similar to the patching process, we empower developers to define contracts in our C-like language, and seamlessly embed these checks into the binary. Unlike patches, contracts are mandated not to alter program state. There are two types of contracts in Patchestry: runtime contracts, addressing unexpected states during runtime, and static contracts, exclusively used for formal verification without persisting in the compiled binary.</p> <pre><code>// Contract\n[[CVE-2021-22156]] void contract(size_t num_elements) {\n    assert(num_elements &lt;= SIZE_MAX/sizeof(long));\n}\n// Meta-contract\nvoid meta_contract(source_module_t module) {\n    for (const callsite_t &amp;place : module.calls(\"calloc\")) {\n        place.apply_before(\"CVE-2021-22156::contract\", { place.operand(1) });\n    }\n}\n</code></pre> <p>An example of Patchestry contract that defines the expected functionality of the program under test written in the C-like Patchestry contracts DSL. A contract is similar to a regression test or a behavioral assertion that an analysis tool like KLEE would check.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Patchestry","text":"<p>First, thanks for your interest in contributing to Patchestry! We welcome and appreciate all contributions, including bug reports, feature suggestions, tutorials/blog posts, and code improvements.</p> <p>If you're unsure where to start, we recommend our <code>good first issue</code> issue label.</p>"},{"location":"CONTRIBUTING/#bug-reports-and-feature-suggestions","title":"Bug reports and feature suggestions","text":"<p>Bug reports and feature suggestions can be submitted to our issue tracker.</p> <p>When reporting a bug please provide a minimal example with steps to reproduce the issue if possible. It helps us a lot, as we can get to the bottom of the issue much faster and can even use it as a test case to catch future regressions.</p>"},{"location":"CONTRIBUTING/#questions","title":"Questions","text":"<p>Questions can be submitted to the discussion page.</p>"},{"location":"CONTRIBUTING/#legal","title":"Legal","text":"<p>For legal reasons, we require contributors to sign our Contributor License Agreement.  This will be automatically checked as part of our CI.</p>"},{"location":"CONTRIBUTING/#git-pull-requests","title":"Git &amp; Pull Requests","text":"<p>Patchestry uses the pull request contribution model. Please make an account on Github, fork this repo, and submit code contributions via pull request. For more documentation, look here.</p> <p>Since Patchestry does not squash commits in a pull request, it is important to uphold some culture when it comes to commits.</p> <ul> <li>Commit should ideally be one simple change.</li> <li>Commit messages follow a simple format:   <code>component: Simple sentence with a dot.</code> with maximum of 80 chars and optional longer   message.</li> <li>When unsure what component commit modifies, run <code>git log</code> on the modified file(s).</li> <li>Commits should modify only one component (as a result the project does not have   to build with each separate commit)</li> <li>If you are having troubles coming up with a simple sentence as a commit message,   that is short enough, it may be a good indicator that the commit should be split.</li> </ul> <p>Some pull request guidelines:</p> <ul> <li>Minimize irrelevant changes (formatting, whitespace, etc) to code that would   otherwise not be touched by this patch. Save formatting or style corrections   for a separate pull request that does not make any semantic changes.</li> <li>When possible, large changes should be split up into smaller focused pull   requests.</li> <li>Fill out the pull request description with a summary of what your patch does,   key changes that have been made, and any further points of discussion, if   applicable.</li> <li>Title your pull request with a brief description of what it's changing.   \"Fixes #123\" is a good comment to add to the description, but makes for an   unclear title on its own.</li> <li>CI must pass for the PR to be merged.</li> <li>There must be a review from some maintainer that accepts changes for the PR to be merged.</li> </ul>"},{"location":"statement/","title":"License","text":"<p>Patchestry is licensed according to the Apache 2.0 license. Patchestry links against and uses Clang and LLVM APIs. Clang is also licensed under Apache 2.0, with LLVM exceptions.</p> <p>This research was developed with funding from the Advanced Research Projects Agency for Health (ARPA-H). The views, opinions and/or findings expressed are those of the author and should not be interpreted as representing the official views or policies of the U.S. Government.</p>"},{"location":"Dialects/Pcode/","title":"Pcode","text":""},{"location":"Dialects/Pcode/#pc-dialect","title":"'pc' Dialect","text":"<p>Dialect for representing ghidra pcode operations. [TOC]</p>"},{"location":"Dialects/Pcode/#operations","title":"Operations","text":""},{"location":"Dialects/Pcode/#pcblock-patchestrypcblockop","title":"<code>pc.block</code> (::patchestry::pc::BlockOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.block` $sym_name attr-dict `:` $instructions\n</code></pre> <p>Traits: <code>NoTerminator</code></p>"},{"location":"Dialects/Pcode/#attributes","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>sym_name</code>::mlir::StringAttrstring attribute"},{"location":"Dialects/Pcode/#pcbool_negate-patchestrypcboolnegateop","title":"<code>pc.bool_negate</code> (::patchestry::pc::BoolNegateOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.bool_negate` $op attr-dict `:` functional-type(operands, results)\n</code></pre> <p>Traits: <code>SameOperandsAndResultType</code></p> <p>Interfaces: <code>InferTypeOpInterface</code></p>"},{"location":"Dialects/Pcode/#operands","title":"Operands:","text":"Operand Description <code>op</code> signless integer"},{"location":"Dialects/Pcode/#results","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcbranch-patchestrypcbranchop","title":"<code>pc.branch</code> (::patchestry::pc::BranchOp)","text":"<p>Pcode BRANCH operation</p> <p>Syntax:</p> <pre><code>operation ::= `pc.branch` $addr attr-dict `:` type(operands)\n</code></pre> <p>TBD</p>"},{"location":"Dialects/Pcode/#operands_1","title":"Operands:","text":"Operand Description <code>addr</code> signless integer"},{"location":"Dialects/Pcode/#pccall-patchestrypccallop","title":"<code>pc.call</code> (::patchestry::pc::CallOp)","text":"<p>Pcode CALL operation</p> <p>Syntax:</p> <pre><code>operation ::= `pc.call` $addr attr-dict `:` type(operands)\n</code></pre> <p>TBD</p>"},{"location":"Dialects/Pcode/#operands_2","title":"Operands:","text":"Operand Description <code>addr</code> signless integer"},{"location":"Dialects/Pcode/#pccbranch-patchestrypccbranchop","title":"<code>pc.cbranch</code> (::patchestry::pc::CBranchOp)","text":"<p>Pcode CBRANCH operation</p> <p>Syntax:</p> <pre><code>operation ::= `pc.cbranch` $addr `,` $cond attr-dict `:` type(operands)\n</code></pre> <p>TBD</p>"},{"location":"Dialects/Pcode/#operands_3","title":"Operands:","text":"Operand Description <code>addr</code> signless integer <code>cond</code> signless integer"},{"location":"Dialects/Pcode/#pcconst-patchestrypcconstop","title":"<code>pc.const</code> (::patchestry::pc::ConstOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.const` attr-dict `:` type($result)\n</code></pre> <p>Traits: <code>ConstantLike</code></p> <p>Interfaces: <code>InferTypeOpInterface</code></p>"},{"location":"Dialects/Pcode/#attributes_1","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>value</code>::mlir::TypedAttrTypedAttr instance{{% markdown %}}     This interface is used for attributes that have a type. The type of an     attribute is understood to represent the type of the data contained in the     attribute and is often used as the type of a value with this data.   {{% /markdown %}}"},{"location":"Dialects/Pcode/#results_1","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"Dialects/Pcode/#pccopy-patchestrypccopyop","title":"<code>pc.copy</code> (::patchestry::pc::CopyOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.copy` $op attr-dict `:` functional-type(operands, results)\n</code></pre> <p>Traits: <code>SameOperandsAndResultType</code></p> <p>Interfaces: <code>InferTypeOpInterface</code></p>"},{"location":"Dialects/Pcode/#operands_4","title":"Operands:","text":"Operand Description <code>op</code> signless integer"},{"location":"Dialects/Pcode/#results_2","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcfunc-patchestrypcfuncop","title":"<code>pc.func</code> (::patchestry::pc::FuncOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.func` $sym_name attr-dict `:` $blocks\n</code></pre> <p>Traits: <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SymbolTable</code></p> <p>Interfaces: <code>Symbol</code></p>"},{"location":"Dialects/Pcode/#attributes_2","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>sym_name</code>::mlir::StringAttrstring attribute"},{"location":"Dialects/Pcode/#pcinstruction-patchestrypcinstop","title":"<code>pc.instruction</code> (::patchestry::pc::InstOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.instruction` attr-dict `:` $semantics\n</code></pre>"},{"location":"Dialects/Pcode/#attributes_3","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>inst_mnemonic</code>::mlir::StringAttrstring attribute"},{"location":"Dialects/Pcode/#pcint_add-patchestrypcintaddop","title":"<code>pc.int_add</code> (::patchestry::pc::IntAddOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_add` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_5","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_3","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcint_and-patchestrypcintandop","title":"<code>pc.int_and</code> (::patchestry::pc::IntAndOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_and` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_6","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_4","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcint_equal-patchestrypcintequalop","title":"<code>pc.int_equal</code> (::patchestry::pc::IntEqualOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_equal` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_7","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_5","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcint_less-patchestrypcintlessop","title":"<code>pc.int_less</code> (::patchestry::pc::IntLessOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_less` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_8","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_6","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcint_sborrow-patchestrypcintsborrowop","title":"<code>pc.int_sborrow</code> (::patchestry::pc::IntSBorrowOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_sborrow` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_9","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_7","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcint_sless-patchestrypcintslessop","title":"<code>pc.int_sless</code> (::patchestry::pc::IntSLessOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_sless` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_10","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_8","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcint_sub-patchestrypcintsubop","title":"<code>pc.int_sub</code> (::patchestry::pc::IntSubOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.int_sub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_11","title":"Operands:","text":"Operand Description <code>lhs</code> signless integer <code>rhs</code> signless integer"},{"location":"Dialects/Pcode/#results_9","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcload-patchestrypcloadop","title":"<code>pc.load</code> (::patchestry::pc::LoadOp)","text":"<p>Pcode LOAD operation</p> <p>Syntax:</p> <pre><code>operation ::= `pc.load` $addr_space `,` $addr attr-dict `:` functional-type(operands, results)\n</code></pre> <p>TBD</p>"},{"location":"Dialects/Pcode/#operands_12","title":"Operands:","text":"Operand Description <code>addr_space</code> signless integer <code>addr</code> signless integer"},{"location":"Dialects/Pcode/#results_10","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcmem-patchestrypcmemop","title":"<code>pc.mem</code> (::patchestry::pc::MemOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.mem` attr-dict `:` type($result)\n</code></pre>"},{"location":"Dialects/Pcode/#attributes_4","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>addr_space</code>::mlir::StringAttrstring attribute <code>addr</code>::mlir::IntegerAttr64-bit signless integer attribute <code>size</code>::mlir::IntegerAttr8-bit signless integer attribute"},{"location":"Dialects/Pcode/#results_11","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"Dialects/Pcode/#pcpopcount-patchestrypcpopcountop","title":"<code>pc.popcount</code> (::patchestry::pc::PopcountOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.popcount` $op attr-dict `:` functional-type(operands, results)\n</code></pre>"},{"location":"Dialects/Pcode/#operands_13","title":"Operands:","text":"Operand Description <code>op</code> signless integer"},{"location":"Dialects/Pcode/#results_12","title":"Results:","text":"Result Description <code>result</code> signless integer"},{"location":"Dialects/Pcode/#pcreg-patchestrypcregop","title":"<code>pc.reg</code> (::patchestry::pc::RegOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.reg` attr-dict `:` type($result)\n</code></pre>"},{"location":"Dialects/Pcode/#attributes_5","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>addr_space</code>::mlir::StringAttrstring attribute <code>addr</code>::mlir::IntegerAttr64-bit signless integer attribute <code>size</code>::mlir::IntegerAttr8-bit signless integer attribute"},{"location":"Dialects/Pcode/#results_13","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"Dialects/Pcode/#pcreturn-patchestrypcreturnop","title":"<code>pc.return</code> (::patchestry::pc::ReturnOp)","text":"<p>Pcode RETURN operation</p> <p>Syntax:</p> <pre><code>operation ::= `pc.return` $varnode attr-dict `:` type(operands)\n</code></pre> <p>TBD</p>"},{"location":"Dialects/Pcode/#operands_14","title":"Operands:","text":"Operand Description <code>varnode</code> signless integer"},{"location":"Dialects/Pcode/#pcstore-patchestrypcstoreop","title":"<code>pc.store</code> (::patchestry::pc::StoreOp)","text":"<p>Pcode STORE operation</p> <p>Syntax:</p> <pre><code>operation ::= `pc.store` $addr_space `,` $addr `,` $data attr-dict `:` type(operands)\n</code></pre> <p>TBD</p>"},{"location":"Dialects/Pcode/#operands_15","title":"Operands:","text":"Operand Description <code>addr_space</code> signless integer <code>addr</code> signless integer <code>data</code> signless integer"},{"location":"Dialects/Pcode/#pcvar-patchestrypcvarop","title":"<code>pc.var</code> (::patchestry::pc::VarOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `pc.var` attr-dict `:` type($result)\n</code></pre>"},{"location":"Dialects/Pcode/#attributes_6","title":"Attributes:","text":"AttributeMLIR TypeDescription <code>addr_space</code>::mlir::StringAttrstring attribute <code>addr</code>::mlir::IntegerAttr64-bit signless integer attribute <code>size</code>::mlir::IntegerAttr8-bit signless integer attribute"},{"location":"Dialects/Pcode/#results_14","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"Dialects/Pcode/#types","title":"Types","text":""},{"location":"Dialects/Pcode/#consttype","title":"ConstType","text":"<p>Syntax: <code>!pc.const</code></p>"},{"location":"Dialects/Pcode/#memtype","title":"MemType","text":"<p>Syntax: <code>!pc.mem</code></p>"},{"location":"Dialects/Pcode/#regtype","title":"RegType","text":"<p>Syntax: <code>!pc.reg</code></p>"},{"location":"Dialects/Pcode/#vartype","title":"VarType","text":"<p>Syntax: <code>!pc.var</code></p>"},{"location":"GettingStarted/build/","title":"Build & Run","text":""},{"location":"GettingStarted/build/#dependencies","title":"Dependencies","text":"Name Version CMake &gt;= 3.25.0 LLVM == 18 <p>Currently, it is necessary to use <code>clang</code> (due to <code>gcc</code> bug) to build Patchestry, because of <code>patchestry</code>. On Linux it is also necessary to use <code>lld</code> at the moment.</p> <p>Patchestry uses <code>llvm-18</code> which can be obtained from the repository provided by LLVM.</p> <p>Before building (for Ubuntu) get all the necessary dependencies by running <pre><code>apt-get install build-essential cmake ninja-build libstdc++-12-dev llvm-18 libmlir-18 libmlir-18-dev mlir-18-tools libclang-18-dev\n</code></pre> or an equivalent command for your operating system of choice.</p>"},{"location":"GettingStarted/build/#ubuntu-2204","title":"Ubuntu 22.04","text":"<p>Optionally (re-)install dependecies from their respective official sources.</p> <pre><code>sudo bash .devcontainer/reinstall-cmake.sh \"3.29.2\"\nsudo bash .devcontainer/install-llvm.sh \"18\" all\n</code></pre> <p>With dependecies installed, we can build in <code>build/</code> in the project root. <pre><code># Assuming `/usr/lib/llvm-18/` contains an llvm-18 installation.\ncmake --preset default -DCMAKE_PREFIX_PATH=/usr/lib/llvm-18/lib/cmake/\n# Valid user presets are `debug`, `release`, `relwithdebinfo`.\ncmake --build --preset=debug\n</code></pre></p>"},{"location":"GettingStarted/build/#getting-ghidra","title":"Getting Ghidra","text":"<p>Get Java JDK (x64)</p> <pre><code>wget -c https://download.oracle.com/java/22/latest/jdk-22_linux-x64_bin.tar.gz -O jdk.tar.gz\ntar xvf jdk.tar.gz\nmv jdk-22.0.1 ~/jdk\necho \"export PATH=\\$PATH:~/jdk/bin\" &gt;&gt; ~/.bashrc\n</code></pre> <p>Get Ghidra <pre><code>wget -c https://github.com/NationalSecurityAgency/ghidra/releases/download/Ghidra_11.1.1_build/ghidra_11.1.1_PUBLIC_20240614.zip -O ghidra.zip\nunzip ghidra.zip\nmv ghidra_11.1.1_PUBLIC ~/ghidra\n</code></pre></p>"},{"location":"GettingStarted/build/#installing-ghidra-scripts","title":"Installing Ghidra Scripts","text":"<p>Link <code>ghidra_scripts</code> directory to <code>$HOME</code>. We assume that <code>./patchestry</code> contains the cloned repository. <pre><code>ln -s patchestry/ghidra_scripts ~\n</code></pre></p>"},{"location":"GettingStarted/build/#instructions","title":"Instructions","text":"<p>To configure project run <code>cmake</code> with following default options. In case <code>clang</code> isn't your default compiler prefix the command with <code>CC=clang CXX=clang++</code>. If you want to use system installed <code>llvm</code> and <code>mlir</code> (on Ubuntu) use:</p> <p>The simplest way is to run</p> <pre><code>cmake --workflow release\n</code></pre> <p>If this method doesn't work for you, configure the project in the usual way:</p> <pre><code>cmake --preset default\n</code></pre> <p>To use a specific <code>llvm</code> provide <code>-DCMAKE_PREFIX_PATH=&lt;llvm &amp; mlir instalation paths&gt;</code> option, where <code>CMAKE_PREFIX_PATH</code> points to directory containing <code>LLVMConfig.cmake</code> and <code>MLIRConfig.cmake</code>.</p> <p>Note: Patchestry requires LLVM with RTTI enabled. Use <code>LLVM_ENABLE_RTTI=ON</code> if you build your own LLVM.</p> <p>Finally, build the project:</p> <pre><code>cmake --build --preset release\n</code></pre> <p>Use <code>debug</code> preset for debug build.</p>"},{"location":"GettingStarted/build/#test","title":"Test","text":"<pre><code>ctest --preset debug\n</code></pre>"},{"location":"GettingStarted/ghidra/","title":"Decompilation Framework","text":"<p>The directory contains a script that runs Ghidra in headless mode to decompile binary files, identifying and listing all functions while extracting their corresponding pcode.</p> <p>We support two decompilation modes:</p> <ol> <li>GUI-based: A user-friendly interface where functions can be decompiled interactively.</li> <li>Headless: Decompilation through a Docker script for automated, non-interactive use.</li> </ol>"},{"location":"GettingStarted/ghidra/#prerequisites","title":"Prerequisites","text":"<p>Before running the scripts, make sure you have the following installed:</p> <ul> <li>Docker: The scripts use a Docker container to run Ghidra in headless mode.</li> </ul> <p>To perform headless decompilation, you need to build a Docker container (<code>decompile-headless.dockerfile</code>) configured to run Ghidra in headless mode. You can do this by running the <code>build-headless-docker.sh</code> script.</p>"},{"location":"GettingStarted/ghidra/#running-headless-decompilation-script","title":"Running Headless Decompilation Script","text":"<p>The <code>decompile-headless.sh</code> script decompiles a binary file using Ghidra in headless mode, extracting pcode for either a specific function or all functions by default, and saving the output as json to a specified file <code>&lt;output-file&gt;</code>.</p> <p>To extract P-code for a particular function, use the <code>--function</code> flag; otherwise, it decompiles all functions if no function name is specified.</p> <p><code>sh ./decompile-headless.sh --input &lt;binary&gt; --function &lt;function-name&gt; --output &lt;output-file&gt;</code></p> <p>The script also list all functions in the binary using the <code>--list-functions</code> flag.</p> <p><code>sh ./decompile-headless.sh --input &lt;binary&gt; --list-functions --output &lt;output-file&gt;</code></p>"},{"location":"GettingStarted/ghidra/#running-patchestry-via-ghidra-gui","title":"Running Patchestry via Ghidra GUI","text":"<ol> <li> <p>Ensure Patchestry is available via PATH:     <pre><code>patchestry\n</code></pre></p> </li> <li> <p>Start Ghidra GUI:     <pre><code>~/ghidra/ghidraRun\n</code></pre></p> </li> <li> <p>Create a project and import a binary file.</p> </li> <li> <p>Run <code>PatchestryDecompileFunctions.java</code> in <code>single</code> or <code>all</code> mode to decompile single or all functions from a binary file.</p> </li> <li> <p>Run <code>PatchestryListFunctions.java</code> script to list all the functions in a binary file.</p> </li> </ol> <p>Note: Ghidra scripts must be installed. See the build section for details.</p>"}]}